{
  "version": 3,
  "sources": ["../../../3D/node_modules/fflate/esm/browser.js", "../../../3D/node_modules/pmtiles/src/index.ts", "../../../3D/node_modules/pmtiles/src/adapters.ts"],
  "sourcesContent": ["// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\r\n// https://tools.ietf.org/html/rfc1951\r\n// You may also wish to take a look at the guide I made about this program:\r\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\r\n// Some of the following code is similar to that of UZIP.js:\r\n// https://github.com/photopea/UZIP.js\r\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\r\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\r\n// is better for memory in most engines (I *think*).\r\nvar ch2 = {};\r\nvar wk = (function (c, id, msg, transfer, cb) {\r\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\r\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\r\n    ], { type: 'text/javascript' }))));\r\n    w.onmessage = function (e) {\r\n        var d = e.data, ed = d.$e$;\r\n        if (ed) {\r\n            var err = new Error(ed[0]);\r\n            err['code'] = ed[1];\r\n            err.stack = ed[2];\r\n            cb(err, null);\r\n        }\r\n        else\r\n            cb(null, d);\r\n    };\r\n    w.postMessage(msg, transfer);\r\n    return w;\r\n});\r\n\r\n// aliases for shorter compressed code (most minifers don't do this)\r\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\r\n// fixed length extra bits\r\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\r\n// fixed distance extra bits\r\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\r\n// code length index map\r\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\r\n// get base, reverse index map from extra bits\r\nvar freb = function (eb, start) {\r\n    var b = new u16(31);\r\n    for (var i = 0; i < 31; ++i) {\r\n        b[i] = start += 1 << eb[i - 1];\r\n    }\r\n    // numbers here are at max 18 bits\r\n    var r = new i32(b[30]);\r\n    for (var i = 1; i < 30; ++i) {\r\n        for (var j = b[i]; j < b[i + 1]; ++j) {\r\n            r[j] = ((j - b[i]) << 5) | i;\r\n        }\r\n    }\r\n    return { b: b, r: r };\r\n};\r\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\r\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\r\nfl[28] = 258, revfl[258] = 28;\r\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\r\n// map of value to reverse (assuming 16 bits)\r\nvar rev = new u16(32768);\r\nfor (var i = 0; i < 32768; ++i) {\r\n    // reverse table algorithm from SO\r\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\r\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\r\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\r\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\r\n}\r\n// create huffman tree from u8 \"map\": index -> code length for code index\r\n// mb (max bits) must be at most 15\r\n// TODO: optimize/split up?\r\nvar hMap = (function (cd, mb, r) {\r\n    var s = cd.length;\r\n    // index\r\n    var i = 0;\r\n    // u16 \"map\": index -> # of codes with bit length = index\r\n    var l = new u16(mb);\r\n    // length of cd must be 288 (total # of codes)\r\n    for (; i < s; ++i) {\r\n        if (cd[i])\r\n            ++l[cd[i] - 1];\r\n    }\r\n    // u16 \"map\": index -> minimum code for bit length = index\r\n    var le = new u16(mb);\r\n    for (i = 1; i < mb; ++i) {\r\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\r\n    }\r\n    var co;\r\n    if (r) {\r\n        // u16 \"map\": index -> number of actual bits, symbol for code\r\n        co = new u16(1 << mb);\r\n        // bits to remove for reverser\r\n        var rvb = 15 - mb;\r\n        for (i = 0; i < s; ++i) {\r\n            // ignore 0 lengths\r\n            if (cd[i]) {\r\n                // num encoding both symbol and bits read\r\n                var sv = (i << 4) | cd[i];\r\n                // free bits\r\n                var r_1 = mb - cd[i];\r\n                // start value\r\n                var v = le[cd[i] - 1]++ << r_1;\r\n                // m is end value\r\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\r\n                    // every 16 bit value starting with the code yields the same result\r\n                    co[rev[v] >> rvb] = sv;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        co = new u16(s);\r\n        for (i = 0; i < s; ++i) {\r\n            if (cd[i]) {\r\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\r\n            }\r\n        }\r\n    }\r\n    return co;\r\n});\r\n// fixed length tree\r\nvar flt = new u8(288);\r\nfor (var i = 0; i < 144; ++i)\r\n    flt[i] = 8;\r\nfor (var i = 144; i < 256; ++i)\r\n    flt[i] = 9;\r\nfor (var i = 256; i < 280; ++i)\r\n    flt[i] = 7;\r\nfor (var i = 280; i < 288; ++i)\r\n    flt[i] = 8;\r\n// fixed distance tree\r\nvar fdt = new u8(32);\r\nfor (var i = 0; i < 32; ++i)\r\n    fdt[i] = 5;\r\n// fixed length map\r\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\r\n// fixed distance map\r\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\r\n// find max of array\r\nvar max = function (a) {\r\n    var m = a[0];\r\n    for (var i = 1; i < a.length; ++i) {\r\n        if (a[i] > m)\r\n            m = a[i];\r\n    }\r\n    return m;\r\n};\r\n// read d, starting at bit p and mask with m\r\nvar bits = function (d, p, m) {\r\n    var o = (p / 8) | 0;\r\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\r\n};\r\n// read d, starting at bit p continuing for at least 16 bits\r\nvar bits16 = function (d, p) {\r\n    var o = (p / 8) | 0;\r\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\r\n};\r\n// get end of byte\r\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\r\n// typed array slice - allows garbage collector to free original reference,\r\n// while being more compatible than .slice\r\nvar slc = function (v, s, e) {\r\n    if (s == null || s < 0)\r\n        s = 0;\r\n    if (e == null || e > v.length)\r\n        e = v.length;\r\n    // can't use .constructor in case user-supplied\r\n    return new u8(v.subarray(s, e));\r\n};\r\n/**\r\n * Codes for errors generated within this library\r\n */\r\nexport var FlateErrorCode = {\r\n    UnexpectedEOF: 0,\r\n    InvalidBlockType: 1,\r\n    InvalidLengthLiteral: 2,\r\n    InvalidDistance: 3,\r\n    StreamFinished: 4,\r\n    NoStreamHandler: 5,\r\n    InvalidHeader: 6,\r\n    NoCallback: 7,\r\n    InvalidUTF8: 8,\r\n    ExtraFieldTooLong: 9,\r\n    InvalidDate: 10,\r\n    FilenameTooLong: 11,\r\n    StreamFinishing: 12,\r\n    InvalidZipData: 13,\r\n    UnknownCompressionMethod: 14\r\n};\r\n// error codes\r\nvar ec = [\r\n    'unexpected EOF',\r\n    'invalid block type',\r\n    'invalid length/literal',\r\n    'invalid distance',\r\n    'stream finished',\r\n    'no stream handler',\r\n    ,\r\n    'no callback',\r\n    'invalid UTF-8 data',\r\n    'extra field too long',\r\n    'date not in range 1980-2099',\r\n    'filename too long',\r\n    'stream finishing',\r\n    'invalid zip data'\r\n    // determined by unknown compression method\r\n];\r\n;\r\nvar err = function (ind, msg, nt) {\r\n    var e = new Error(msg || ec[ind]);\r\n    e.code = ind;\r\n    if (Error.captureStackTrace)\r\n        Error.captureStackTrace(e, err);\r\n    if (!nt)\r\n        throw e;\r\n    return e;\r\n};\r\n// expands raw DEFLATE data\r\nvar inflt = function (dat, st, buf, dict) {\r\n    // source length       dict length\r\n    var sl = dat.length, dl = dict ? dict.length : 0;\r\n    if (!sl || st.f && !st.l)\r\n        return buf || new u8(0);\r\n    var noBuf = !buf;\r\n    // have to estimate size\r\n    var resize = noBuf || st.i != 2;\r\n    // no state\r\n    var noSt = st.i;\r\n    // Assumes roughly 33% compression ratio average\r\n    if (noBuf)\r\n        buf = new u8(sl * 3);\r\n    // ensure buffer can fit at least l elements\r\n    var cbuf = function (l) {\r\n        var bl = buf.length;\r\n        // need to increase size to fit\r\n        if (l > bl) {\r\n            // Double or set to necessary, whichever is greater\r\n            var nbuf = new u8(Math.max(bl * 2, l));\r\n            nbuf.set(buf);\r\n            buf = nbuf;\r\n        }\r\n    };\r\n    //  last chunk         bitpos           bytes\r\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\r\n    // total bits\r\n    var tbts = sl * 8;\r\n    do {\r\n        if (!lm) {\r\n            // BFINAL - this is only 1 when last chunk is next\r\n            final = bits(dat, pos, 1);\r\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\r\n            var type = bits(dat, pos + 1, 3);\r\n            pos += 3;\r\n            if (!type) {\r\n                // go to end of byte boundary\r\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\r\n                if (t > sl) {\r\n                    if (noSt)\r\n                        err(0);\r\n                    break;\r\n                }\r\n                // ensure size\r\n                if (resize)\r\n                    cbuf(bt + l);\r\n                // Copy over uncompressed data\r\n                buf.set(dat.subarray(s, t), bt);\r\n                // Get new bitpos, update byte count\r\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\r\n                continue;\r\n            }\r\n            else if (type == 1)\r\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\r\n            else if (type == 2) {\r\n                //  literal                            lengths\r\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\r\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\r\n                pos += 14;\r\n                // length+distance tree\r\n                var ldt = new u8(tl);\r\n                // code length tree\r\n                var clt = new u8(19);\r\n                for (var i = 0; i < hcLen; ++i) {\r\n                    // use index map to get real code\r\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\r\n                }\r\n                pos += hcLen * 3;\r\n                // code lengths bits\r\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\r\n                // code lengths map\r\n                var clm = hMap(clt, clb, 1);\r\n                for (var i = 0; i < tl;) {\r\n                    var r = clm[bits(dat, pos, clbmsk)];\r\n                    // bits read\r\n                    pos += r & 15;\r\n                    // symbol\r\n                    var s = r >> 4;\r\n                    // code length to copy\r\n                    if (s < 16) {\r\n                        ldt[i++] = s;\r\n                    }\r\n                    else {\r\n                        //  copy   count\r\n                        var c = 0, n = 0;\r\n                        if (s == 16)\r\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\r\n                        else if (s == 17)\r\n                            n = 3 + bits(dat, pos, 7), pos += 3;\r\n                        else if (s == 18)\r\n                            n = 11 + bits(dat, pos, 127), pos += 7;\r\n                        while (n--)\r\n                            ldt[i++] = c;\r\n                    }\r\n                }\r\n                //    length tree                 distance tree\r\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\r\n                // max length bits\r\n                lbt = max(lt);\r\n                // max dist bits\r\n                dbt = max(dt);\r\n                lm = hMap(lt, lbt, 1);\r\n                dm = hMap(dt, dbt, 1);\r\n            }\r\n            else\r\n                err(1);\r\n            if (pos > tbts) {\r\n                if (noSt)\r\n                    err(0);\r\n                break;\r\n            }\r\n        }\r\n        // Make sure the buffer can hold this + the largest possible addition\r\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\r\n        if (resize)\r\n            cbuf(bt + 131072);\r\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\r\n        var lpos = pos;\r\n        for (;; lpos = pos) {\r\n            // bits read, code\r\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\r\n            pos += c & 15;\r\n            if (pos > tbts) {\r\n                if (noSt)\r\n                    err(0);\r\n                break;\r\n            }\r\n            if (!c)\r\n                err(2);\r\n            if (sym < 256)\r\n                buf[bt++] = sym;\r\n            else if (sym == 256) {\r\n                lpos = pos, lm = null;\r\n                break;\r\n            }\r\n            else {\r\n                var add = sym - 254;\r\n                // no extra bits needed if less\r\n                if (sym > 264) {\r\n                    // index\r\n                    var i = sym - 257, b = fleb[i];\r\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\r\n                    pos += b;\r\n                }\r\n                // dist\r\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\r\n                if (!d)\r\n                    err(3);\r\n                pos += d & 15;\r\n                var dt = fd[dsym];\r\n                if (dsym > 3) {\r\n                    var b = fdeb[dsym];\r\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\r\n                }\r\n                if (pos > tbts) {\r\n                    if (noSt)\r\n                        err(0);\r\n                    break;\r\n                }\r\n                if (resize)\r\n                    cbuf(bt + 131072);\r\n                var end = bt + add;\r\n                if (bt < dt) {\r\n                    var shift = dl - dt, dend = Math.min(dt, end);\r\n                    if (shift + bt < 0)\r\n                        err(3);\r\n                    for (; bt < dend; ++bt)\r\n                        buf[bt] = dict[shift + bt];\r\n                }\r\n                for (; bt < end; ++bt)\r\n                    buf[bt] = buf[bt - dt];\r\n            }\r\n        }\r\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\r\n        if (lm)\r\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\r\n    } while (!final);\r\n    // don't reallocate for streams or user buffers\r\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\r\n};\r\n// starting at p, write the minimum number of bits that can hold v to d\r\nvar wbits = function (d, p, v) {\r\n    v <<= p & 7;\r\n    var o = (p / 8) | 0;\r\n    d[o] |= v;\r\n    d[o + 1] |= v >> 8;\r\n};\r\n// starting at p, write the minimum number of bits (>8) that can hold v to d\r\nvar wbits16 = function (d, p, v) {\r\n    v <<= p & 7;\r\n    var o = (p / 8) | 0;\r\n    d[o] |= v;\r\n    d[o + 1] |= v >> 8;\r\n    d[o + 2] |= v >> 16;\r\n};\r\n// creates code lengths from a frequency table\r\nvar hTree = function (d, mb) {\r\n    // Need extra info to make a tree\r\n    var t = [];\r\n    for (var i = 0; i < d.length; ++i) {\r\n        if (d[i])\r\n            t.push({ s: i, f: d[i] });\r\n    }\r\n    var s = t.length;\r\n    var t2 = t.slice();\r\n    if (!s)\r\n        return { t: et, l: 0 };\r\n    if (s == 1) {\r\n        var v = new u8(t[0].s + 1);\r\n        v[t[0].s] = 1;\r\n        return { t: v, l: 1 };\r\n    }\r\n    t.sort(function (a, b) { return a.f - b.f; });\r\n    // after i2 reaches last ind, will be stopped\r\n    // freq must be greater than largest possible number of symbols\r\n    t.push({ s: -1, f: 25001 });\r\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\r\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\r\n    // efficient algorithm from UZIP.js\r\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\r\n    // symbols that combined have high freq, will start processing i2 (high-freq,\r\n    // non-composite) symbols instead\r\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\r\n    while (i1 != s - 1) {\r\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\r\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\r\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\r\n    }\r\n    var maxSym = t2[0].s;\r\n    for (var i = 1; i < s; ++i) {\r\n        if (t2[i].s > maxSym)\r\n            maxSym = t2[i].s;\r\n    }\r\n    // code lengths\r\n    var tr = new u16(maxSym + 1);\r\n    // max bits in tree\r\n    var mbt = ln(t[i1 - 1], tr, 0);\r\n    if (mbt > mb) {\r\n        // more algorithms from UZIP.js\r\n        // TODO: find out how this code works (debt)\r\n        //  ind    debt\r\n        var i = 0, dt = 0;\r\n        //    left            cost\r\n        var lft = mbt - mb, cst = 1 << lft;\r\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\r\n        for (; i < s; ++i) {\r\n            var i2_1 = t2[i].s;\r\n            if (tr[i2_1] > mb) {\r\n                dt += cst - (1 << (mbt - tr[i2_1]));\r\n                tr[i2_1] = mb;\r\n            }\r\n            else\r\n                break;\r\n        }\r\n        dt >>= lft;\r\n        while (dt > 0) {\r\n            var i2_2 = t2[i].s;\r\n            if (tr[i2_2] < mb)\r\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\r\n            else\r\n                ++i;\r\n        }\r\n        for (; i >= 0 && dt; --i) {\r\n            var i2_3 = t2[i].s;\r\n            if (tr[i2_3] == mb) {\r\n                --tr[i2_3];\r\n                ++dt;\r\n            }\r\n        }\r\n        mbt = mb;\r\n    }\r\n    return { t: new u8(tr), l: mbt };\r\n};\r\n// get the max length and assign length codes\r\nvar ln = function (n, l, d) {\r\n    return n.s == -1\r\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\r\n        : (l[n.s] = d);\r\n};\r\n// length codes generation\r\nvar lc = function (c) {\r\n    var s = c.length;\r\n    // Note that the semicolon was intentional\r\n    while (s && !c[--s])\r\n        ;\r\n    var cl = new u16(++s);\r\n    //  ind      num         streak\r\n    var cli = 0, cln = c[0], cls = 1;\r\n    var w = function (v) { cl[cli++] = v; };\r\n    for (var i = 1; i <= s; ++i) {\r\n        if (c[i] == cln && i != s)\r\n            ++cls;\r\n        else {\r\n            if (!cln && cls > 2) {\r\n                for (; cls > 138; cls -= 138)\r\n                    w(32754);\r\n                if (cls > 2) {\r\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\r\n                    cls = 0;\r\n                }\r\n            }\r\n            else if (cls > 3) {\r\n                w(cln), --cls;\r\n                for (; cls > 6; cls -= 6)\r\n                    w(8304);\r\n                if (cls > 2)\r\n                    w(((cls - 3) << 5) | 8208), cls = 0;\r\n            }\r\n            while (cls--)\r\n                w(cln);\r\n            cls = 1;\r\n            cln = c[i];\r\n        }\r\n    }\r\n    return { c: cl.subarray(0, cli), n: s };\r\n};\r\n// calculate the length of output from tree, code lengths\r\nvar clen = function (cf, cl) {\r\n    var l = 0;\r\n    for (var i = 0; i < cl.length; ++i)\r\n        l += cf[i] * cl[i];\r\n    return l;\r\n};\r\n// writes a fixed block\r\n// returns the new bit pos\r\nvar wfblk = function (out, pos, dat) {\r\n    // no need to write 00 as type: TypedArray defaults to 0\r\n    var s = dat.length;\r\n    var o = shft(pos + 2);\r\n    out[o] = s & 255;\r\n    out[o + 1] = s >> 8;\r\n    out[o + 2] = out[o] ^ 255;\r\n    out[o + 3] = out[o + 1] ^ 255;\r\n    for (var i = 0; i < s; ++i)\r\n        out[o + i + 4] = dat[i];\r\n    return (o + 4 + s) * 8;\r\n};\r\n// writes a block\r\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\r\n    wbits(out, p++, final);\r\n    ++lf[256];\r\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\r\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\r\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\r\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\r\n    var lcfreq = new u16(19);\r\n    for (var i = 0; i < lclt.length; ++i)\r\n        ++lcfreq[lclt[i] & 31];\r\n    for (var i = 0; i < lcdt.length; ++i)\r\n        ++lcfreq[lcdt[i] & 31];\r\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\r\n    var nlcc = 19;\r\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\r\n        ;\r\n    var flen = (bl + 5) << 3;\r\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\r\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\r\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\r\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\r\n    var lm, ll, dm, dl;\r\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\r\n    if (dtlen < ftlen) {\r\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\r\n        var llm = hMap(lct, mlcb, 0);\r\n        wbits(out, p, nlc - 257);\r\n        wbits(out, p + 5, ndc - 1);\r\n        wbits(out, p + 10, nlcc - 4);\r\n        p += 14;\r\n        for (var i = 0; i < nlcc; ++i)\r\n            wbits(out, p + 3 * i, lct[clim[i]]);\r\n        p += 3 * nlcc;\r\n        var lcts = [lclt, lcdt];\r\n        for (var it = 0; it < 2; ++it) {\r\n            var clct = lcts[it];\r\n            for (var i = 0; i < clct.length; ++i) {\r\n                var len = clct[i] & 31;\r\n                wbits(out, p, llm[len]), p += lct[len];\r\n                if (len > 15)\r\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\r\n    }\r\n    for (var i = 0; i < li; ++i) {\r\n        var sym = syms[i];\r\n        if (sym > 255) {\r\n            var len = (sym >> 18) & 31;\r\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\r\n            if (len > 7)\r\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\r\n            var dst = sym & 31;\r\n            wbits16(out, p, dm[dst]), p += dl[dst];\r\n            if (dst > 3)\r\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\r\n        }\r\n        else {\r\n            wbits16(out, p, lm[sym]), p += ll[sym];\r\n        }\r\n    }\r\n    wbits16(out, p, lm[256]);\r\n    return p + ll[256];\r\n};\r\n// deflate options (nice << 13) | chain\r\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\r\n// empty\r\nvar et = /*#__PURE__*/ new u8(0);\r\n// compresses data into a raw DEFLATE buffer\r\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\r\n    var s = st.z || dat.length;\r\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\r\n    // writing to this writes to the output buffer\r\n    var w = o.subarray(pre, o.length - post);\r\n    var lst = st.l;\r\n    var pos = (st.r || 0) & 7;\r\n    if (lvl) {\r\n        if (pos)\r\n            w[0] = st.r >> 3;\r\n        var opt = deo[lvl - 1];\r\n        var n = opt >> 13, c = opt & 8191;\r\n        var msk_1 = (1 << plvl) - 1;\r\n        //    prev 2-byte val map    curr 2-byte val map\r\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\r\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\r\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\r\n        // 24576 is an arbitrary number of maximum symbols per block\r\n        // 424 buffer for last block\r\n        var syms = new i32(25000);\r\n        // length/literal freq   distance freq\r\n        var lf = new u16(288), df = new u16(32);\r\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\r\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\r\n        for (; i + 2 < s; ++i) {\r\n            // hash value\r\n            var hv = hsh(i);\r\n            // index mod 32768    previous index mod\r\n            var imod = i & 32767, pimod = head[hv];\r\n            prev[imod] = pimod;\r\n            head[hv] = imod;\r\n            // We always should modify head and prev, but only add symbols if\r\n            // this data is not yet processed (\"wait\" for wait index)\r\n            if (wi <= i) {\r\n                // bytes remaining\r\n                var rem = s - i;\r\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\r\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\r\n                    li = lc_1 = eb = 0, bs = i;\r\n                    for (var j = 0; j < 286; ++j)\r\n                        lf[j] = 0;\r\n                    for (var j = 0; j < 30; ++j)\r\n                        df[j] = 0;\r\n                }\r\n                //  len    dist   chain\r\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\r\n                if (rem > 2 && hv == hsh(i - dif)) {\r\n                    var maxn = Math.min(n, rem) - 1;\r\n                    var maxd = Math.min(32767, i);\r\n                    // max possible length\r\n                    // not capped at dif because decompressors implement \"rolling\" index population\r\n                    var ml = Math.min(258, rem);\r\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\r\n                        if (dat[i + l] == dat[i + l - dif]) {\r\n                            var nl = 0;\r\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\r\n                                ;\r\n                            if (nl > l) {\r\n                                l = nl, d = dif;\r\n                                // break out early when we reach \"nice\" (we are satisfied enough)\r\n                                if (nl > maxn)\r\n                                    break;\r\n                                // now, find the rarest 2-byte sequence within this\r\n                                // length of literals and search for that instead.\r\n                                // Much faster than just using the start\r\n                                var mmd = Math.min(dif, nl - 2);\r\n                                var md = 0;\r\n                                for (var j = 0; j < mmd; ++j) {\r\n                                    var ti = i - dif + j & 32767;\r\n                                    var pti = prev[ti];\r\n                                    var cd = ti - pti & 32767;\r\n                                    if (cd > md)\r\n                                        md = cd, pimod = ti;\r\n                                }\r\n                            }\r\n                        }\r\n                        // check the previous match\r\n                        imod = pimod, pimod = prev[imod];\r\n                        dif += imod - pimod & 32767;\r\n                    }\r\n                }\r\n                // d will be nonzero only when a match was found\r\n                if (d) {\r\n                    // store both dist and len data in one int32\r\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\r\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\r\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\r\n                    eb += fleb[lin] + fdeb[din];\r\n                    ++lf[257 + lin];\r\n                    ++df[din];\r\n                    wi = i + l;\r\n                    ++lc_1;\r\n                }\r\n                else {\r\n                    syms[li++] = dat[i];\r\n                    ++lf[dat[i]];\r\n                }\r\n            }\r\n        }\r\n        for (i = Math.max(i, wi); i < s; ++i) {\r\n            syms[li++] = dat[i];\r\n            ++lf[dat[i]];\r\n        }\r\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\r\n        if (!lst) {\r\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\r\n            // shft(pos) now 1 less if pos & 7 != 0\r\n            pos -= 7;\r\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\r\n        }\r\n    }\r\n    else {\r\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\r\n            // end\r\n            var e = i + 65535;\r\n            if (e >= s) {\r\n                // write final block\r\n                w[(pos / 8) | 0] = lst;\r\n                e = s;\r\n            }\r\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\r\n        }\r\n        st.i = s;\r\n    }\r\n    return slc(o, 0, pre + shft(pos) + post);\r\n};\r\n// CRC32 table\r\nvar crct = /*#__PURE__*/ (function () {\r\n    var t = new Int32Array(256);\r\n    for (var i = 0; i < 256; ++i) {\r\n        var c = i, k = 9;\r\n        while (--k)\r\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\r\n        t[i] = c;\r\n    }\r\n    return t;\r\n})();\r\n// CRC32\r\nvar crc = function () {\r\n    var c = -1;\r\n    return {\r\n        p: function (d) {\r\n            // closures have awful performance\r\n            var cr = c;\r\n            for (var i = 0; i < d.length; ++i)\r\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\r\n            c = cr;\r\n        },\r\n        d: function () { return ~c; }\r\n    };\r\n};\r\n// Adler32\r\nvar adler = function () {\r\n    var a = 1, b = 0;\r\n    return {\r\n        p: function (d) {\r\n            // closures have awful performance\r\n            var n = a, m = b;\r\n            var l = d.length | 0;\r\n            for (var i = 0; i != l;) {\r\n                var e = Math.min(i + 2655, l);\r\n                for (; i < e; ++i)\r\n                    m += n += d[i];\r\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\r\n            }\r\n            a = n, b = m;\r\n        },\r\n        d: function () {\r\n            a %= 65521, b %= 65521;\r\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\r\n        }\r\n    };\r\n};\r\n;\r\n// deflate with opts\r\nvar dopt = function (dat, opt, pre, post, st) {\r\n    if (!st) {\r\n        st = { l: 1 };\r\n        if (opt.dictionary) {\r\n            var dict = opt.dictionary.subarray(-32768);\r\n            var newDat = new u8(dict.length + dat.length);\r\n            newDat.set(dict);\r\n            newDat.set(dat, dict.length);\r\n            dat = newDat;\r\n            st.w = dict.length;\r\n        }\r\n    }\r\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\r\n};\r\n// Walmart object spread\r\nvar mrg = function (a, b) {\r\n    var o = {};\r\n    for (var k in a)\r\n        o[k] = a[k];\r\n    for (var k in b)\r\n        o[k] = b[k];\r\n    return o;\r\n};\r\n// worker clone\r\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\r\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\r\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\r\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\r\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\r\n// This took me three weeks to figure out how to do.\r\nvar wcln = function (fn, fnStr, td) {\r\n    var dt = fn();\r\n    var st = fn.toString();\r\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\r\n    for (var i = 0; i < dt.length; ++i) {\r\n        var v = dt[i], k = ks[i];\r\n        if (typeof v == 'function') {\r\n            fnStr += ';' + k + '=';\r\n            var st_1 = v.toString();\r\n            if (v.prototype) {\r\n                // for global objects\r\n                if (st_1.indexOf('[native code]') != -1) {\r\n                    var spInd = st_1.indexOf(' ', 8) + 1;\r\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\r\n                }\r\n                else {\r\n                    fnStr += st_1;\r\n                    for (var t in v.prototype)\r\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\r\n                }\r\n            }\r\n            else\r\n                fnStr += st_1;\r\n        }\r\n        else\r\n            td[k] = v;\r\n    }\r\n    return fnStr;\r\n};\r\nvar ch = [];\r\n// clone bufs\r\nvar cbfs = function (v) {\r\n    var tl = [];\r\n    for (var k in v) {\r\n        if (v[k].buffer) {\r\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\r\n        }\r\n    }\r\n    return tl;\r\n};\r\n// use a worker to execute code\r\nvar wrkr = function (fns, init, id, cb) {\r\n    if (!ch[id]) {\r\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\r\n        for (var i = 0; i < m; ++i)\r\n            fnStr = wcln(fns[i], fnStr, td_1);\r\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\r\n    }\r\n    var td = mrg({}, ch[id].e);\r\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\r\n};\r\n// base async inflate fn\r\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\r\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\r\n// gzip extra\r\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\r\n// gunzip extra\r\nvar guze = function () { return [gzs, gzl]; };\r\n// zlib extra\r\nvar zle = function () { return [zlh, wbytes, adler]; };\r\n// unzlib extra\r\nvar zule = function () { return [zls]; };\r\n// post buf\r\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\r\n// get opts\r\nvar gopt = function (o) { return o && {\r\n    out: o.size && new u8(o.size),\r\n    dictionary: o.dictionary\r\n}; };\r\n// async helper\r\nvar cbify = function (dat, opts, fns, init, id, cb) {\r\n    var w = wrkr(fns, init, id, function (err, dat) {\r\n        w.terminate();\r\n        cb(err, dat);\r\n    });\r\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\r\n    return function () { w.terminate(); };\r\n};\r\n// auto stream\r\nvar astrm = function (strm) {\r\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\r\n    return function (ev) {\r\n        if (ev.data.length) {\r\n            strm.push(ev.data[0], ev.data[1]);\r\n            postMessage([ev.data[0].length]);\r\n        }\r\n        else\r\n            strm.flush();\r\n    };\r\n};\r\n// async stream attach\r\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\r\n    var t;\r\n    var w = wrkr(fns, init, id, function (err, dat) {\r\n        if (err)\r\n            w.terminate(), strm.ondata.call(strm, err);\r\n        else if (!Array.isArray(dat))\r\n            ext(dat);\r\n        else if (dat.length == 1) {\r\n            strm.queuedSize -= dat[0];\r\n            if (strm.ondrain)\r\n                strm.ondrain(dat[0]);\r\n        }\r\n        else {\r\n            if (dat[1])\r\n                w.terminate();\r\n            strm.ondata.call(strm, err, dat[0], dat[1]);\r\n        }\r\n    });\r\n    w.postMessage(opts);\r\n    strm.queuedSize = 0;\r\n    strm.push = function (d, f) {\r\n        if (!strm.ondata)\r\n            err(5);\r\n        if (t)\r\n            strm.ondata(err(4, 0, 1), null, !!f);\r\n        strm.queuedSize += d.length;\r\n        w.postMessage([d, t = f], [d.buffer]);\r\n    };\r\n    strm.terminate = function () { w.terminate(); };\r\n    if (flush) {\r\n        strm.flush = function () { w.postMessage([]); };\r\n    }\r\n};\r\n// read 2 bytes\r\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\r\n// read 4 bytes\r\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\r\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\r\n// write bytes\r\nvar wbytes = function (d, b, v) {\r\n    for (; v; ++b)\r\n        d[b] = v, v >>>= 8;\r\n};\r\n// gzip header\r\nvar gzh = function (c, o) {\r\n    var fn = o.filename;\r\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\r\n    if (o.mtime != 0)\r\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\r\n    if (fn) {\r\n        c[3] = 8;\r\n        for (var i = 0; i <= fn.length; ++i)\r\n            c[i + 10] = fn.charCodeAt(i);\r\n    }\r\n};\r\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\r\n// gzip start\r\nvar gzs = function (d) {\r\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\r\n        err(6, 'invalid gzip data');\r\n    var flg = d[3];\r\n    var st = 10;\r\n    if (flg & 4)\r\n        st += (d[10] | d[11] << 8) + 2;\r\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\r\n        ;\r\n    return st + (flg & 2);\r\n};\r\n// gzip length\r\nvar gzl = function (d) {\r\n    var l = d.length;\r\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\r\n};\r\n// gzip header length\r\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\r\n// zlib header\r\nvar zlh = function (c, o) {\r\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\r\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\r\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\r\n    if (o.dictionary) {\r\n        var h = adler();\r\n        h.p(o.dictionary);\r\n        wbytes(c, 2, h.d());\r\n    }\r\n};\r\n// zlib start\r\nvar zls = function (d, dict) {\r\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\r\n        err(6, 'invalid zlib data');\r\n    if ((d[1] >> 5 & 1) == +!dict)\r\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\r\n    return (d[1] >> 3 & 4) + 2;\r\n};\r\nfunction StrmOpt(opts, cb) {\r\n    if (typeof opts == 'function')\r\n        cb = opts, opts = {};\r\n    this.ondata = cb;\r\n    return opts;\r\n}\r\n/**\r\n * Streaming DEFLATE compression\r\n */\r\nvar Deflate = /*#__PURE__*/ (function () {\r\n    function Deflate(opts, cb) {\r\n        if (typeof opts == 'function')\r\n            cb = opts, opts = {};\r\n        this.ondata = cb;\r\n        this.o = opts || {};\r\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\r\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\r\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\r\n        this.b = new u8(98304);\r\n        if (this.o.dictionary) {\r\n            var dict = this.o.dictionary.subarray(-32768);\r\n            this.b.set(dict, 32768 - dict.length);\r\n            this.s.i = 32768 - dict.length;\r\n        }\r\n    }\r\n    Deflate.prototype.p = function (c, f) {\r\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\r\n    };\r\n    /**\r\n     * Pushes a chunk to be deflated\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    Deflate.prototype.push = function (chunk, final) {\r\n        if (!this.ondata)\r\n            err(5);\r\n        if (this.s.l)\r\n            err(4);\r\n        var endLen = chunk.length + this.s.z;\r\n        if (endLen > this.b.length) {\r\n            if (endLen > 2 * this.b.length - 32768) {\r\n                var newBuf = new u8(endLen & -32768);\r\n                newBuf.set(this.b.subarray(0, this.s.z));\r\n                this.b = newBuf;\r\n            }\r\n            var split = this.b.length - this.s.z;\r\n            this.b.set(chunk.subarray(0, split), this.s.z);\r\n            this.s.z = this.b.length;\r\n            this.p(this.b, false);\r\n            this.b.set(this.b.subarray(-32768));\r\n            this.b.set(chunk.subarray(split), 32768);\r\n            this.s.z = chunk.length - split + 32768;\r\n            this.s.i = 32766, this.s.w = 32768;\r\n        }\r\n        else {\r\n            this.b.set(chunk, this.s.z);\r\n            this.s.z += chunk.length;\r\n        }\r\n        this.s.l = final & 1;\r\n        if (this.s.z > this.s.w + 8191 || final) {\r\n            this.p(this.b, final || false);\r\n            this.s.w = this.s.i, this.s.i -= 2;\r\n        }\r\n    };\r\n    /**\r\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\r\n     * deflated output for small inputs.\r\n     */\r\n    Deflate.prototype.flush = function () {\r\n        if (!this.ondata)\r\n            err(5);\r\n        if (this.s.l)\r\n            err(4);\r\n        this.p(this.b, false);\r\n        this.s.w = this.s.i, this.s.i -= 2;\r\n    };\r\n    return Deflate;\r\n}());\r\nexport { Deflate };\r\n/**\r\n * Asynchronous streaming DEFLATE compression\r\n */\r\nvar AsyncDeflate = /*#__PURE__*/ (function () {\r\n    function AsyncDeflate(opts, cb) {\r\n        astrmify([\r\n            bDflt,\r\n            function () { return [astrm, Deflate]; }\r\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\r\n            var strm = new Deflate(ev.data);\r\n            onmessage = astrm(strm);\r\n        }, 6, 1);\r\n    }\r\n    return AsyncDeflate;\r\n}());\r\nexport { AsyncDeflate };\r\nexport function deflate(data, opts, cb) {\r\n    if (!cb)\r\n        cb = opts, opts = {};\r\n    if (typeof cb != 'function')\r\n        err(7);\r\n    return cbify(data, opts, [\r\n        bDflt,\r\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\r\n}\r\n/**\r\n * Compresses data with DEFLATE without any wrapper\r\n * @param data The data to compress\r\n * @param opts The compression options\r\n * @returns The deflated version of the data\r\n */\r\nexport function deflateSync(data, opts) {\r\n    return dopt(data, opts || {}, 0, 0);\r\n}\r\n/**\r\n * Streaming DEFLATE decompression\r\n */\r\nvar Inflate = /*#__PURE__*/ (function () {\r\n    function Inflate(opts, cb) {\r\n        // no StrmOpt here to avoid adding to workerizer\r\n        if (typeof opts == 'function')\r\n            cb = opts, opts = {};\r\n        this.ondata = cb;\r\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\r\n        this.s = { i: 0, b: dict ? dict.length : 0 };\r\n        this.o = new u8(32768);\r\n        this.p = new u8(0);\r\n        if (dict)\r\n            this.o.set(dict);\r\n    }\r\n    Inflate.prototype.e = function (c) {\r\n        if (!this.ondata)\r\n            err(5);\r\n        if (this.d)\r\n            err(4);\r\n        if (!this.p.length)\r\n            this.p = c;\r\n        else if (c.length) {\r\n            var n = new u8(this.p.length + c.length);\r\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\r\n        }\r\n    };\r\n    Inflate.prototype.c = function (final) {\r\n        this.s.i = +(this.d = final || false);\r\n        var bts = this.s.b;\r\n        var dt = inflt(this.p, this.s, this.o);\r\n        this.ondata(slc(dt, bts, this.s.b), this.d);\r\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\r\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\r\n    };\r\n    /**\r\n     * Pushes a chunk to be inflated\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the final chunk\r\n     */\r\n    Inflate.prototype.push = function (chunk, final) {\r\n        this.e(chunk), this.c(final);\r\n    };\r\n    return Inflate;\r\n}());\r\nexport { Inflate };\r\n/**\r\n * Asynchronous streaming DEFLATE decompression\r\n */\r\nvar AsyncInflate = /*#__PURE__*/ (function () {\r\n    function AsyncInflate(opts, cb) {\r\n        astrmify([\r\n            bInflt,\r\n            function () { return [astrm, Inflate]; }\r\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\r\n            var strm = new Inflate(ev.data);\r\n            onmessage = astrm(strm);\r\n        }, 7, 0);\r\n    }\r\n    return AsyncInflate;\r\n}());\r\nexport { AsyncInflate };\r\nexport function inflate(data, opts, cb) {\r\n    if (!cb)\r\n        cb = opts, opts = {};\r\n    if (typeof cb != 'function')\r\n        err(7);\r\n    return cbify(data, opts, [\r\n        bInflt\r\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\r\n}\r\n/**\r\n * Expands DEFLATE data with no wrapper\r\n * @param data The data to decompress\r\n * @param opts The decompression options\r\n * @returns The decompressed version of the data\r\n */\r\nexport function inflateSync(data, opts) {\r\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\r\n}\r\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\r\n/**\r\n * Streaming GZIP compression\r\n */\r\nvar Gzip = /*#__PURE__*/ (function () {\r\n    function Gzip(opts, cb) {\r\n        this.c = crc();\r\n        this.l = 0;\r\n        this.v = 1;\r\n        Deflate.call(this, opts, cb);\r\n    }\r\n    /**\r\n     * Pushes a chunk to be GZIPped\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    Gzip.prototype.push = function (chunk, final) {\r\n        this.c.p(chunk);\r\n        this.l += chunk.length;\r\n        Deflate.prototype.push.call(this, chunk, final);\r\n    };\r\n    Gzip.prototype.p = function (c, f) {\r\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\r\n        if (this.v)\r\n            gzh(raw, this.o), this.v = 0;\r\n        if (f)\r\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\r\n        this.ondata(raw, f);\r\n    };\r\n    /**\r\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\r\n     * GZIPped output for small inputs.\r\n     */\r\n    Gzip.prototype.flush = function () {\r\n        Deflate.prototype.flush.call(this);\r\n    };\r\n    return Gzip;\r\n}());\r\nexport { Gzip };\r\n/**\r\n * Asynchronous streaming GZIP compression\r\n */\r\nvar AsyncGzip = /*#__PURE__*/ (function () {\r\n    function AsyncGzip(opts, cb) {\r\n        astrmify([\r\n            bDflt,\r\n            gze,\r\n            function () { return [astrm, Deflate, Gzip]; }\r\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\r\n            var strm = new Gzip(ev.data);\r\n            onmessage = astrm(strm);\r\n        }, 8, 1);\r\n    }\r\n    return AsyncGzip;\r\n}());\r\nexport { AsyncGzip };\r\nexport function gzip(data, opts, cb) {\r\n    if (!cb)\r\n        cb = opts, opts = {};\r\n    if (typeof cb != 'function')\r\n        err(7);\r\n    return cbify(data, opts, [\r\n        bDflt,\r\n        gze,\r\n        function () { return [gzipSync]; }\r\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\r\n}\r\n/**\r\n * Compresses data with GZIP\r\n * @param data The data to compress\r\n * @param opts The compression options\r\n * @returns The gzipped version of the data\r\n */\r\nexport function gzipSync(data, opts) {\r\n    if (!opts)\r\n        opts = {};\r\n    var c = crc(), l = data.length;\r\n    c.p(data);\r\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\r\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\r\n}\r\n/**\r\n * Streaming single or multi-member GZIP decompression\r\n */\r\nvar Gunzip = /*#__PURE__*/ (function () {\r\n    function Gunzip(opts, cb) {\r\n        this.v = 1;\r\n        this.r = 0;\r\n        Inflate.call(this, opts, cb);\r\n    }\r\n    /**\r\n     * Pushes a chunk to be GUNZIPped\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    Gunzip.prototype.push = function (chunk, final) {\r\n        Inflate.prototype.e.call(this, chunk);\r\n        this.r += chunk.length;\r\n        if (this.v) {\r\n            var p = this.p.subarray(this.v - 1);\r\n            var s = p.length > 3 ? gzs(p) : 4;\r\n            if (s > p.length) {\r\n                if (!final)\r\n                    return;\r\n            }\r\n            else if (this.v > 1 && this.onmember) {\r\n                this.onmember(this.r - p.length);\r\n            }\r\n            this.p = p.subarray(s), this.v = 0;\r\n        }\r\n        // necessary to prevent TS from using the closure value\r\n        // This allows for workerization to function correctly\r\n        Inflate.prototype.c.call(this, final);\r\n        // process concatenated GZIP\r\n        if (this.s.f && !this.s.l && !final) {\r\n            this.v = shft(this.s.p) + 9;\r\n            this.s = { i: 0 };\r\n            this.o = new u8(0);\r\n            this.push(new u8(0), final);\r\n        }\r\n    };\r\n    return Gunzip;\r\n}());\r\nexport { Gunzip };\r\n/**\r\n * Asynchronous streaming single or multi-member GZIP decompression\r\n */\r\nvar AsyncGunzip = /*#__PURE__*/ (function () {\r\n    function AsyncGunzip(opts, cb) {\r\n        var _this = this;\r\n        astrmify([\r\n            bInflt,\r\n            guze,\r\n            function () { return [astrm, Inflate, Gunzip]; }\r\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\r\n            var strm = new Gunzip(ev.data);\r\n            strm.onmember = function (offset) { return postMessage(offset); };\r\n            onmessage = astrm(strm);\r\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\r\n    }\r\n    return AsyncGunzip;\r\n}());\r\nexport { AsyncGunzip };\r\nexport function gunzip(data, opts, cb) {\r\n    if (!cb)\r\n        cb = opts, opts = {};\r\n    if (typeof cb != 'function')\r\n        err(7);\r\n    return cbify(data, opts, [\r\n        bInflt,\r\n        guze,\r\n        function () { return [gunzipSync]; }\r\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\r\n}\r\n/**\r\n * Expands GZIP data\r\n * @param data The data to decompress\r\n * @param opts The decompression options\r\n * @returns The decompressed version of the data\r\n */\r\nexport function gunzipSync(data, opts) {\r\n    var st = gzs(data);\r\n    if (st + 8 > data.length)\r\n        err(6, 'invalid gzip data');\r\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\r\n}\r\n/**\r\n * Streaming Zlib compression\r\n */\r\nvar Zlib = /*#__PURE__*/ (function () {\r\n    function Zlib(opts, cb) {\r\n        this.c = adler();\r\n        this.v = 1;\r\n        Deflate.call(this, opts, cb);\r\n    }\r\n    /**\r\n     * Pushes a chunk to be zlibbed\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    Zlib.prototype.push = function (chunk, final) {\r\n        this.c.p(chunk);\r\n        Deflate.prototype.push.call(this, chunk, final);\r\n    };\r\n    Zlib.prototype.p = function (c, f) {\r\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\r\n        if (this.v)\r\n            zlh(raw, this.o), this.v = 0;\r\n        if (f)\r\n            wbytes(raw, raw.length - 4, this.c.d());\r\n        this.ondata(raw, f);\r\n    };\r\n    /**\r\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\r\n     * zlibbed output for small inputs.\r\n     */\r\n    Zlib.prototype.flush = function () {\r\n        Deflate.prototype.flush.call(this);\r\n    };\r\n    return Zlib;\r\n}());\r\nexport { Zlib };\r\n/**\r\n * Asynchronous streaming Zlib compression\r\n */\r\nvar AsyncZlib = /*#__PURE__*/ (function () {\r\n    function AsyncZlib(opts, cb) {\r\n        astrmify([\r\n            bDflt,\r\n            zle,\r\n            function () { return [astrm, Deflate, Zlib]; }\r\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\r\n            var strm = new Zlib(ev.data);\r\n            onmessage = astrm(strm);\r\n        }, 10, 1);\r\n    }\r\n    return AsyncZlib;\r\n}());\r\nexport { AsyncZlib };\r\nexport function zlib(data, opts, cb) {\r\n    if (!cb)\r\n        cb = opts, opts = {};\r\n    if (typeof cb != 'function')\r\n        err(7);\r\n    return cbify(data, opts, [\r\n        bDflt,\r\n        zle,\r\n        function () { return [zlibSync]; }\r\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\r\n}\r\n/**\r\n * Compress data with Zlib\r\n * @param data The data to compress\r\n * @param opts The compression options\r\n * @returns The zlib-compressed version of the data\r\n */\r\nexport function zlibSync(data, opts) {\r\n    if (!opts)\r\n        opts = {};\r\n    var a = adler();\r\n    a.p(data);\r\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\r\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\r\n}\r\n/**\r\n * Streaming Zlib decompression\r\n */\r\nvar Unzlib = /*#__PURE__*/ (function () {\r\n    function Unzlib(opts, cb) {\r\n        Inflate.call(this, opts, cb);\r\n        this.v = opts && opts.dictionary ? 2 : 1;\r\n    }\r\n    /**\r\n     * Pushes a chunk to be unzlibbed\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    Unzlib.prototype.push = function (chunk, final) {\r\n        Inflate.prototype.e.call(this, chunk);\r\n        if (this.v) {\r\n            if (this.p.length < 6 && !final)\r\n                return;\r\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\r\n        }\r\n        if (final) {\r\n            if (this.p.length < 4)\r\n                err(6, 'invalid zlib data');\r\n            this.p = this.p.subarray(0, -4);\r\n        }\r\n        // necessary to prevent TS from using the closure value\r\n        // This allows for workerization to function correctly\r\n        Inflate.prototype.c.call(this, final);\r\n    };\r\n    return Unzlib;\r\n}());\r\nexport { Unzlib };\r\n/**\r\n * Asynchronous streaming Zlib decompression\r\n */\r\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\r\n    function AsyncUnzlib(opts, cb) {\r\n        astrmify([\r\n            bInflt,\r\n            zule,\r\n            function () { return [astrm, Inflate, Unzlib]; }\r\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\r\n            var strm = new Unzlib(ev.data);\r\n            onmessage = astrm(strm);\r\n        }, 11, 0);\r\n    }\r\n    return AsyncUnzlib;\r\n}());\r\nexport { AsyncUnzlib };\r\nexport function unzlib(data, opts, cb) {\r\n    if (!cb)\r\n        cb = opts, opts = {};\r\n    if (typeof cb != 'function')\r\n        err(7);\r\n    return cbify(data, opts, [\r\n        bInflt,\r\n        zule,\r\n        function () { return [unzlibSync]; }\r\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\r\n}\r\n/**\r\n * Expands Zlib data\r\n * @param data The data to decompress\r\n * @param opts The decompression options\r\n * @returns The decompressed version of the data\r\n */\r\nexport function unzlibSync(data, opts) {\r\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\r\n}\r\n// Default algorithm for compression (used because having a known output size allows faster decompression)\r\nexport { gzip as compress, AsyncGzip as AsyncCompress };\r\nexport { gzipSync as compressSync, Gzip as Compress };\r\n/**\r\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\r\n */\r\nvar Decompress = /*#__PURE__*/ (function () {\r\n    function Decompress(opts, cb) {\r\n        this.o = StrmOpt.call(this, opts, cb) || {};\r\n        this.G = Gunzip;\r\n        this.I = Inflate;\r\n        this.Z = Unzlib;\r\n    }\r\n    // init substream\r\n    // overriden by AsyncDecompress\r\n    Decompress.prototype.i = function () {\r\n        var _this = this;\r\n        this.s.ondata = function (dat, final) {\r\n            _this.ondata(dat, final);\r\n        };\r\n    };\r\n    /**\r\n     * Pushes a chunk to be decompressed\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    Decompress.prototype.push = function (chunk, final) {\r\n        if (!this.ondata)\r\n            err(5);\r\n        if (!this.s) {\r\n            if (this.p && this.p.length) {\r\n                var n = new u8(this.p.length + chunk.length);\r\n                n.set(this.p), n.set(chunk, this.p.length);\r\n            }\r\n            else\r\n                this.p = chunk;\r\n            if (this.p.length > 2) {\r\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\r\n                    ? new this.G(this.o)\r\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\r\n                        ? new this.I(this.o)\r\n                        : new this.Z(this.o);\r\n                this.i();\r\n                this.s.push(this.p, final);\r\n                this.p = null;\r\n            }\r\n        }\r\n        else\r\n            this.s.push(chunk, final);\r\n    };\r\n    return Decompress;\r\n}());\r\nexport { Decompress };\r\n/**\r\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\r\n */\r\nvar AsyncDecompress = /*#__PURE__*/ (function () {\r\n    function AsyncDecompress(opts, cb) {\r\n        Decompress.call(this, opts, cb);\r\n        this.queuedSize = 0;\r\n        this.G = AsyncGunzip;\r\n        this.I = AsyncInflate;\r\n        this.Z = AsyncUnzlib;\r\n    }\r\n    AsyncDecompress.prototype.i = function () {\r\n        var _this = this;\r\n        this.s.ondata = function (err, dat, final) {\r\n            _this.ondata(err, dat, final);\r\n        };\r\n        this.s.ondrain = function (size) {\r\n            _this.queuedSize -= size;\r\n            if (_this.ondrain)\r\n                _this.ondrain(size);\r\n        };\r\n    };\r\n    /**\r\n     * Pushes a chunk to be decompressed\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    AsyncDecompress.prototype.push = function (chunk, final) {\r\n        this.queuedSize += chunk.length;\r\n        Decompress.prototype.push.call(this, chunk, final);\r\n    };\r\n    return AsyncDecompress;\r\n}());\r\nexport { AsyncDecompress };\r\nexport function decompress(data, opts, cb) {\r\n    if (!cb)\r\n        cb = opts, opts = {};\r\n    if (typeof cb != 'function')\r\n        err(7);\r\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\r\n        ? gunzip(data, opts, cb)\r\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\r\n            ? inflate(data, opts, cb)\r\n            : unzlib(data, opts, cb);\r\n}\r\n/**\r\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\r\n * @param data The data to decompress\r\n * @param opts The decompression options\r\n * @returns The decompressed version of the data\r\n */\r\nexport function decompressSync(data, opts) {\r\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\r\n        ? gunzipSync(data, opts)\r\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\r\n            ? inflateSync(data, opts)\r\n            : unzlibSync(data, opts);\r\n}\r\n// flatten a directory structure\r\nvar fltn = function (d, p, t, o) {\r\n    for (var k in d) {\r\n        var val = d[k], n = p + k, op = o;\r\n        if (Array.isArray(val))\r\n            op = mrg(o, val[1]), val = val[0];\r\n        if (val instanceof u8)\r\n            t[n] = [val, op];\r\n        else {\r\n            t[n += '/'] = [new u8(0), op];\r\n            fltn(val, n, t, o);\r\n        }\r\n    }\r\n};\r\n// text encoder\r\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\r\n// text decoder\r\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\r\n// text decoder stream\r\nvar tds = 0;\r\ntry {\r\n    td.decode(et, { stream: true });\r\n    tds = 1;\r\n}\r\ncatch (e) { }\r\n// decode UTF8\r\nvar dutf8 = function (d) {\r\n    for (var r = '', i = 0;;) {\r\n        var c = d[i++];\r\n        var eb = (c > 127) + (c > 223) + (c > 239);\r\n        if (i + eb > d.length)\r\n            return { s: r, r: slc(d, i - 1) };\r\n        if (!eb)\r\n            r += String.fromCharCode(c);\r\n        else if (eb == 3) {\r\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\r\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\r\n        }\r\n        else if (eb & 1)\r\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\r\n        else\r\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\r\n    }\r\n};\r\n/**\r\n * Streaming UTF-8 decoding\r\n */\r\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates a UTF-8 decoding stream\r\n     * @param cb The callback to call whenever data is decoded\r\n     */\r\n    function DecodeUTF8(cb) {\r\n        this.ondata = cb;\r\n        if (tds)\r\n            this.t = new TextDecoder();\r\n        else\r\n            this.p = et;\r\n    }\r\n    /**\r\n     * Pushes a chunk to be decoded from UTF-8 binary\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    DecodeUTF8.prototype.push = function (chunk, final) {\r\n        if (!this.ondata)\r\n            err(5);\r\n        final = !!final;\r\n        if (this.t) {\r\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\r\n            if (final) {\r\n                if (this.t.decode().length)\r\n                    err(8);\r\n                this.t = null;\r\n            }\r\n            return;\r\n        }\r\n        if (!this.p)\r\n            err(4);\r\n        var dat = new u8(this.p.length + chunk.length);\r\n        dat.set(this.p);\r\n        dat.set(chunk, this.p.length);\r\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\r\n        if (final) {\r\n            if (r.length)\r\n                err(8);\r\n            this.p = null;\r\n        }\r\n        else\r\n            this.p = r;\r\n        this.ondata(s, final);\r\n    };\r\n    return DecodeUTF8;\r\n}());\r\nexport { DecodeUTF8 };\r\n/**\r\n * Streaming UTF-8 encoding\r\n */\r\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates a UTF-8 decoding stream\r\n     * @param cb The callback to call whenever data is encoded\r\n     */\r\n    function EncodeUTF8(cb) {\r\n        this.ondata = cb;\r\n    }\r\n    /**\r\n     * Pushes a chunk to be encoded to UTF-8\r\n     * @param chunk The string data to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    EncodeUTF8.prototype.push = function (chunk, final) {\r\n        if (!this.ondata)\r\n            err(5);\r\n        if (this.d)\r\n            err(4);\r\n        this.ondata(strToU8(chunk), this.d = final || false);\r\n    };\r\n    return EncodeUTF8;\r\n}());\r\nexport { EncodeUTF8 };\r\n/**\r\n * Converts a string into a Uint8Array for use with compression/decompression methods\r\n * @param str The string to encode\r\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\r\n *               not need to be true unless decoding a binary string.\r\n * @returns The string encoded in UTF-8/Latin-1 binary\r\n */\r\nexport function strToU8(str, latin1) {\r\n    if (latin1) {\r\n        var ar_1 = new u8(str.length);\r\n        for (var i = 0; i < str.length; ++i)\r\n            ar_1[i] = str.charCodeAt(i);\r\n        return ar_1;\r\n    }\r\n    if (te)\r\n        return te.encode(str);\r\n    var l = str.length;\r\n    var ar = new u8(str.length + (str.length >> 1));\r\n    var ai = 0;\r\n    var w = function (v) { ar[ai++] = v; };\r\n    for (var i = 0; i < l; ++i) {\r\n        if (ai + 5 > ar.length) {\r\n            var n = new u8(ai + 8 + ((l - i) << 1));\r\n            n.set(ar);\r\n            ar = n;\r\n        }\r\n        var c = str.charCodeAt(i);\r\n        if (c < 128 || latin1)\r\n            w(c);\r\n        else if (c < 2048)\r\n            w(192 | (c >> 6)), w(128 | (c & 63));\r\n        else if (c > 55295 && c < 57344)\r\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\r\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\r\n        else\r\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\r\n    }\r\n    return slc(ar, 0, ai);\r\n}\r\n/**\r\n * Converts a Uint8Array to a string\r\n * @param dat The data to decode to string\r\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\r\n *               not need to be true unless encoding to binary string.\r\n * @returns The original UTF-8/Latin-1 string\r\n */\r\nexport function strFromU8(dat, latin1) {\r\n    if (latin1) {\r\n        var r = '';\r\n        for (var i = 0; i < dat.length; i += 16384)\r\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\r\n        return r;\r\n    }\r\n    else if (td) {\r\n        return td.decode(dat);\r\n    }\r\n    else {\r\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\r\n        if (r.length)\r\n            err(8);\r\n        return s;\r\n    }\r\n}\r\n;\r\n// deflate bit flag\r\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\r\n// skip local zip header\r\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\r\n// read zip header\r\nvar zh = function (d, b, z) {\r\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\r\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\r\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\r\n};\r\n// read zip64 extra field\r\nvar z64e = function (d, b) {\r\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\r\n        ;\r\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\r\n};\r\n// extra field length\r\nvar exfl = function (ex) {\r\n    var le = 0;\r\n    if (ex) {\r\n        for (var k in ex) {\r\n            var l = ex[k].length;\r\n            if (l > 65535)\r\n                err(9);\r\n            le += l + 4;\r\n        }\r\n    }\r\n    return le;\r\n};\r\n// write zip header\r\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\r\n    var fl = fn.length, ex = f.extra, col = co && co.length;\r\n    var exl = exfl(ex);\r\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\r\n    if (ce != null)\r\n        d[b++] = 20, d[b++] = f.os;\r\n    d[b] = 20, b += 2; // spec compliance? what's that?\r\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\r\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\r\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\r\n    if (y < 0 || y > 119)\r\n        err(10);\r\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\r\n    if (c != -1) {\r\n        wbytes(d, b, f.crc);\r\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\r\n        wbytes(d, b + 8, f.size);\r\n    }\r\n    wbytes(d, b + 12, fl);\r\n    wbytes(d, b + 14, exl), b += 16;\r\n    if (ce != null) {\r\n        wbytes(d, b, col);\r\n        wbytes(d, b + 6, f.attrs);\r\n        wbytes(d, b + 10, ce), b += 14;\r\n    }\r\n    d.set(fn, b);\r\n    b += fl;\r\n    if (exl) {\r\n        for (var k in ex) {\r\n            var exf = ex[k], l = exf.length;\r\n            wbytes(d, b, +k);\r\n            wbytes(d, b + 2, l);\r\n            d.set(exf, b + 4), b += 4 + l;\r\n        }\r\n    }\r\n    if (col)\r\n        d.set(co, b), b += col;\r\n    return b;\r\n};\r\n// write zip footer (end of central directory)\r\nvar wzf = function (o, b, c, d, e) {\r\n    wbytes(o, b, 0x6054B50); // skip disk\r\n    wbytes(o, b + 8, c);\r\n    wbytes(o, b + 10, c);\r\n    wbytes(o, b + 12, d);\r\n    wbytes(o, b + 16, e);\r\n};\r\n/**\r\n * A pass-through stream to keep data uncompressed in a ZIP archive.\r\n */\r\nvar ZipPassThrough = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates a pass-through stream that can be added to ZIP archives\r\n     * @param filename The filename to associate with this data stream\r\n     */\r\n    function ZipPassThrough(filename) {\r\n        this.filename = filename;\r\n        this.c = crc();\r\n        this.size = 0;\r\n        this.compression = 0;\r\n    }\r\n    /**\r\n     * Processes a chunk and pushes to the output stream. You can override this\r\n     * method in a subclass for custom behavior, but by default this passes\r\n     * the data through. You must call this.ondata(err, chunk, final) at some\r\n     * point in this method.\r\n     * @param chunk The chunk to process\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    ZipPassThrough.prototype.process = function (chunk, final) {\r\n        this.ondata(null, chunk, final);\r\n    };\r\n    /**\r\n     * Pushes a chunk to be added. If you are subclassing this with a custom\r\n     * compression algorithm, note that you must push data from the source\r\n     * file only, pre-compression.\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    ZipPassThrough.prototype.push = function (chunk, final) {\r\n        if (!this.ondata)\r\n            err(5);\r\n        this.c.p(chunk);\r\n        this.size += chunk.length;\r\n        if (final)\r\n            this.crc = this.c.d();\r\n        this.process(chunk, final || false);\r\n    };\r\n    return ZipPassThrough;\r\n}());\r\nexport { ZipPassThrough };\r\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\r\n/**\r\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\r\n * for better performance\r\n */\r\nvar ZipDeflate = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates a DEFLATE stream that can be added to ZIP archives\r\n     * @param filename The filename to associate with this data stream\r\n     * @param opts The compression options\r\n     */\r\n    function ZipDeflate(filename, opts) {\r\n        var _this = this;\r\n        if (!opts)\r\n            opts = {};\r\n        ZipPassThrough.call(this, filename);\r\n        this.d = new Deflate(opts, function (dat, final) {\r\n            _this.ondata(null, dat, final);\r\n        });\r\n        this.compression = 8;\r\n        this.flag = dbf(opts.level);\r\n    }\r\n    ZipDeflate.prototype.process = function (chunk, final) {\r\n        try {\r\n            this.d.push(chunk, final);\r\n        }\r\n        catch (e) {\r\n            this.ondata(e, null, final);\r\n        }\r\n    };\r\n    /**\r\n     * Pushes a chunk to be deflated\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    ZipDeflate.prototype.push = function (chunk, final) {\r\n        ZipPassThrough.prototype.push.call(this, chunk, final);\r\n    };\r\n    return ZipDeflate;\r\n}());\r\nexport { ZipDeflate };\r\n/**\r\n * Asynchronous streaming DEFLATE compression for ZIP archives\r\n */\r\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\r\n     * @param filename The filename to associate with this data stream\r\n     * @param opts The compression options\r\n     */\r\n    function AsyncZipDeflate(filename, opts) {\r\n        var _this = this;\r\n        if (!opts)\r\n            opts = {};\r\n        ZipPassThrough.call(this, filename);\r\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\r\n            _this.ondata(err, dat, final);\r\n        });\r\n        this.compression = 8;\r\n        this.flag = dbf(opts.level);\r\n        this.terminate = this.d.terminate;\r\n    }\r\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\r\n        this.d.push(chunk, final);\r\n    };\r\n    /**\r\n     * Pushes a chunk to be deflated\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\r\n        ZipPassThrough.prototype.push.call(this, chunk, final);\r\n    };\r\n    return AsyncZipDeflate;\r\n}());\r\nexport { AsyncZipDeflate };\r\n// TODO: Better tree shaking\r\n/**\r\n * A zippable archive to which files can incrementally be added\r\n */\r\nvar Zip = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates an empty ZIP archive to which files can be added\r\n     * @param cb The callback to call whenever data for the generated ZIP archive\r\n     *           is available\r\n     */\r\n    function Zip(cb) {\r\n        this.ondata = cb;\r\n        this.u = [];\r\n        this.d = 1;\r\n    }\r\n    /**\r\n     * Adds a file to the ZIP archive\r\n     * @param file The file stream to add\r\n     */\r\n    Zip.prototype.add = function (file) {\r\n        var _this = this;\r\n        if (!this.ondata)\r\n            err(5);\r\n        // finishing or finished\r\n        if (this.d & 2)\r\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\r\n        else {\r\n            var f = strToU8(file.filename), fl_1 = f.length;\r\n            var com = file.comment, o = com && strToU8(com);\r\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\r\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\r\n            if (fl_1 > 65535)\r\n                this.ondata(err(11, 0, 1), null, false);\r\n            var header = new u8(hl_1);\r\n            wzh(header, 0, file, f, u, -1);\r\n            var chks_1 = [header];\r\n            var pAll_1 = function () {\r\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\r\n                    var chk = chks_2[_i];\r\n                    _this.ondata(null, chk, false);\r\n                }\r\n                chks_1 = [];\r\n            };\r\n            var tr_1 = this.d;\r\n            this.d = 0;\r\n            var ind_1 = this.u.length;\r\n            var uf_1 = mrg(file, {\r\n                f: f,\r\n                u: u,\r\n                o: o,\r\n                t: function () {\r\n                    if (file.terminate)\r\n                        file.terminate();\r\n                },\r\n                r: function () {\r\n                    pAll_1();\r\n                    if (tr_1) {\r\n                        var nxt = _this.u[ind_1 + 1];\r\n                        if (nxt)\r\n                            nxt.r();\r\n                        else\r\n                            _this.d = 1;\r\n                    }\r\n                    tr_1 = 1;\r\n                }\r\n            });\r\n            var cl_1 = 0;\r\n            file.ondata = function (err, dat, final) {\r\n                if (err) {\r\n                    _this.ondata(err, dat, final);\r\n                    _this.terminate();\r\n                }\r\n                else {\r\n                    cl_1 += dat.length;\r\n                    chks_1.push(dat);\r\n                    if (final) {\r\n                        var dd = new u8(16);\r\n                        wbytes(dd, 0, 0x8074B50);\r\n                        wbytes(dd, 4, file.crc);\r\n                        wbytes(dd, 8, cl_1);\r\n                        wbytes(dd, 12, file.size);\r\n                        chks_1.push(dd);\r\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\r\n                        if (tr_1)\r\n                            uf_1.r();\r\n                        tr_1 = 1;\r\n                    }\r\n                    else if (tr_1)\r\n                        pAll_1();\r\n                }\r\n            };\r\n            this.u.push(uf_1);\r\n        }\r\n    };\r\n    /**\r\n     * Ends the process of adding files and prepares to emit the final chunks.\r\n     * This *must* be called after adding all desired files for the resulting\r\n     * ZIP file to work properly.\r\n     */\r\n    Zip.prototype.end = function () {\r\n        var _this = this;\r\n        if (this.d & 2) {\r\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\r\n            return;\r\n        }\r\n        if (this.d)\r\n            this.e();\r\n        else\r\n            this.u.push({\r\n                r: function () {\r\n                    if (!(_this.d & 1))\r\n                        return;\r\n                    _this.u.splice(-1, 1);\r\n                    _this.e();\r\n                },\r\n                t: function () { }\r\n            });\r\n        this.d = 3;\r\n    };\r\n    Zip.prototype.e = function () {\r\n        var bt = 0, l = 0, tl = 0;\r\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\r\n            var f = _a[_i];\r\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\r\n        }\r\n        var out = new u8(tl + 22);\r\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\r\n            var f = _c[_b];\r\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\r\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\r\n        }\r\n        wzf(out, bt, this.u.length, tl, l);\r\n        this.ondata(null, out, true);\r\n        this.d = 2;\r\n    };\r\n    /**\r\n     * A method to terminate any internal workers used by the stream. Subsequent\r\n     * calls to add() will fail.\r\n     */\r\n    Zip.prototype.terminate = function () {\r\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\r\n            var f = _a[_i];\r\n            f.t();\r\n        }\r\n        this.d = 2;\r\n    };\r\n    return Zip;\r\n}());\r\nexport { Zip };\r\nexport function zip(data, opts, cb) {\r\n    if (!cb)\r\n        cb = opts, opts = {};\r\n    if (typeof cb != 'function')\r\n        err(7);\r\n    var r = {};\r\n    fltn(data, '', r, opts);\r\n    var k = Object.keys(r);\r\n    var lft = k.length, o = 0, tot = 0;\r\n    var slft = lft, files = new Array(lft);\r\n    var term = [];\r\n    var tAll = function () {\r\n        for (var i = 0; i < term.length; ++i)\r\n            term[i]();\r\n    };\r\n    var cbd = function (a, b) {\r\n        mt(function () { cb(a, b); });\r\n    };\r\n    mt(function () { cbd = cb; });\r\n    var cbf = function () {\r\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\r\n        tot = 0;\r\n        for (var i = 0; i < slft; ++i) {\r\n            var f = files[i];\r\n            try {\r\n                var l = f.c.length;\r\n                wzh(out, tot, f, f.f, f.u, l);\r\n                var badd = 30 + f.f.length + exfl(f.extra);\r\n                var loc = tot + badd;\r\n                out.set(f.c, loc);\r\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\r\n            }\r\n            catch (e) {\r\n                return cbd(e, null);\r\n            }\r\n        }\r\n        wzf(out, o, files.length, cdl, oe);\r\n        cbd(null, out);\r\n    };\r\n    if (!lft)\r\n        cbf();\r\n    var _loop_1 = function (i) {\r\n        var fn = k[i];\r\n        var _a = r[fn], file = _a[0], p = _a[1];\r\n        var c = crc(), size = file.length;\r\n        c.p(file);\r\n        var f = strToU8(fn), s = f.length;\r\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\r\n        var exl = exfl(p.extra);\r\n        var compression = p.level == 0 ? 0 : 8;\r\n        var cbl = function (e, d) {\r\n            if (e) {\r\n                tAll();\r\n                cbd(e, null);\r\n            }\r\n            else {\r\n                var l = d.length;\r\n                files[i] = mrg(p, {\r\n                    size: size,\r\n                    crc: c.d(),\r\n                    c: d,\r\n                    f: f,\r\n                    m: m,\r\n                    u: s != fn.length || (m && (com.length != ms)),\r\n                    compression: compression\r\n                });\r\n                o += 30 + s + exl + l;\r\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\r\n                if (!--lft)\r\n                    cbf();\r\n            }\r\n        };\r\n        if (s > 65535)\r\n            cbl(err(11, 0, 1), null);\r\n        if (!compression)\r\n            cbl(null, file);\r\n        else if (size < 160000) {\r\n            try {\r\n                cbl(null, deflateSync(file, p));\r\n            }\r\n            catch (e) {\r\n                cbl(e, null);\r\n            }\r\n        }\r\n        else\r\n            term.push(deflate(file, p, cbl));\r\n    };\r\n    // Cannot use lft because it can decrease\r\n    for (var i = 0; i < slft; ++i) {\r\n        _loop_1(i);\r\n    }\r\n    return tAll;\r\n}\r\n/**\r\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\r\n * with more than one file.\r\n * @param data The directory structure for the ZIP archive\r\n * @param opts The main options, merged with per-file options\r\n * @returns The generated ZIP archive\r\n */\r\nexport function zipSync(data, opts) {\r\n    if (!opts)\r\n        opts = {};\r\n    var r = {};\r\n    var files = [];\r\n    fltn(data, '', r, opts);\r\n    var o = 0;\r\n    var tot = 0;\r\n    for (var fn in r) {\r\n        var _a = r[fn], file = _a[0], p = _a[1];\r\n        var compression = p.level == 0 ? 0 : 8;\r\n        var f = strToU8(fn), s = f.length;\r\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\r\n        var exl = exfl(p.extra);\r\n        if (s > 65535)\r\n            err(11);\r\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\r\n        var c = crc();\r\n        c.p(file);\r\n        files.push(mrg(p, {\r\n            size: file.length,\r\n            crc: c.d(),\r\n            c: d,\r\n            f: f,\r\n            m: m,\r\n            u: s != fn.length || (m && (com.length != ms)),\r\n            o: o,\r\n            compression: compression\r\n        }));\r\n        o += 30 + s + exl + l;\r\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\r\n    }\r\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\r\n    for (var i = 0; i < files.length; ++i) {\r\n        var f = files[i];\r\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\r\n        var badd = 30 + f.f.length + exfl(f.extra);\r\n        out.set(f.c, f.o + badd);\r\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\r\n    }\r\n    wzf(out, o, files.length, cdl, oe);\r\n    return out;\r\n}\r\n/**\r\n * Streaming pass-through decompression for ZIP archives\r\n */\r\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\r\n    function UnzipPassThrough() {\r\n    }\r\n    UnzipPassThrough.prototype.push = function (data, final) {\r\n        this.ondata(null, data, final);\r\n    };\r\n    UnzipPassThrough.compression = 0;\r\n    return UnzipPassThrough;\r\n}());\r\nexport { UnzipPassThrough };\r\n/**\r\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\r\n * better performance.\r\n */\r\nvar UnzipInflate = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates a DEFLATE decompression that can be used in ZIP archives\r\n     */\r\n    function UnzipInflate() {\r\n        var _this = this;\r\n        this.i = new Inflate(function (dat, final) {\r\n            _this.ondata(null, dat, final);\r\n        });\r\n    }\r\n    UnzipInflate.prototype.push = function (data, final) {\r\n        try {\r\n            this.i.push(data, final);\r\n        }\r\n        catch (e) {\r\n            this.ondata(e, null, final);\r\n        }\r\n    };\r\n    UnzipInflate.compression = 8;\r\n    return UnzipInflate;\r\n}());\r\nexport { UnzipInflate };\r\n/**\r\n * Asynchronous streaming DEFLATE decompression for ZIP archives\r\n */\r\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates a DEFLATE decompression that can be used in ZIP archives\r\n     */\r\n    function AsyncUnzipInflate(_, sz) {\r\n        var _this = this;\r\n        if (sz < 320000) {\r\n            this.i = new Inflate(function (dat, final) {\r\n                _this.ondata(null, dat, final);\r\n            });\r\n        }\r\n        else {\r\n            this.i = new AsyncInflate(function (err, dat, final) {\r\n                _this.ondata(err, dat, final);\r\n            });\r\n            this.terminate = this.i.terminate;\r\n        }\r\n    }\r\n    AsyncUnzipInflate.prototype.push = function (data, final) {\r\n        if (this.i.terminate)\r\n            data = slc(data, 0);\r\n        this.i.push(data, final);\r\n    };\r\n    AsyncUnzipInflate.compression = 8;\r\n    return AsyncUnzipInflate;\r\n}());\r\nexport { AsyncUnzipInflate };\r\n/**\r\n * A ZIP archive decompression stream that emits files as they are discovered\r\n */\r\nvar Unzip = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates a ZIP decompression stream\r\n     * @param cb The callback to call whenever a file in the ZIP archive is found\r\n     */\r\n    function Unzip(cb) {\r\n        this.onfile = cb;\r\n        this.k = [];\r\n        this.o = {\r\n            0: UnzipPassThrough\r\n        };\r\n        this.p = et;\r\n    }\r\n    /**\r\n     * Pushes a chunk to be unzipped\r\n     * @param chunk The chunk to push\r\n     * @param final Whether this is the last chunk\r\n     */\r\n    Unzip.prototype.push = function (chunk, final) {\r\n        var _this = this;\r\n        if (!this.onfile)\r\n            err(5);\r\n        if (!this.p)\r\n            err(4);\r\n        if (this.c > 0) {\r\n            var len = Math.min(this.c, chunk.length);\r\n            var toAdd = chunk.subarray(0, len);\r\n            this.c -= len;\r\n            if (this.d)\r\n                this.d.push(toAdd, !this.c);\r\n            else\r\n                this.k[0].push(toAdd);\r\n            chunk = chunk.subarray(len);\r\n            if (chunk.length)\r\n                return this.push(chunk, final);\r\n        }\r\n        else {\r\n            var f = 0, i = 0, is = void 0, buf = void 0;\r\n            if (!this.p.length)\r\n                buf = chunk;\r\n            else if (!chunk.length)\r\n                buf = this.p;\r\n            else {\r\n                buf = new u8(this.p.length + chunk.length);\r\n                buf.set(this.p), buf.set(chunk, this.p.length);\r\n            }\r\n            var l = buf.length, oc = this.c, add = oc && this.d;\r\n            var _loop_2 = function () {\r\n                var _a;\r\n                var sig = b4(buf, i);\r\n                if (sig == 0x4034B50) {\r\n                    f = 1, is = i;\r\n                    this_1.d = null;\r\n                    this_1.c = 0;\r\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\r\n                    if (l > i + 30 + fnl + es) {\r\n                        var chks_3 = [];\r\n                        this_1.k.unshift(chks_3);\r\n                        f = 2;\r\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\r\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\r\n                        if (sc_1 == 4294967295) {\r\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\r\n                        }\r\n                        else if (dd)\r\n                            sc_1 = -1;\r\n                        i += es;\r\n                        this_1.c = sc_1;\r\n                        var d_1;\r\n                        var file_1 = {\r\n                            name: fn_1,\r\n                            compression: cmp_1,\r\n                            start: function () {\r\n                                if (!file_1.ondata)\r\n                                    err(5);\r\n                                if (!sc_1)\r\n                                    file_1.ondata(null, et, true);\r\n                                else {\r\n                                    var ctr = _this.o[cmp_1];\r\n                                    if (!ctr)\r\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\r\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\r\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\r\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\r\n                                        var dat = chks_4[_i];\r\n                                        d_1.push(dat, false);\r\n                                    }\r\n                                    if (_this.k[0] == chks_3 && _this.c)\r\n                                        _this.d = d_1;\r\n                                    else\r\n                                        d_1.push(et, true);\r\n                                }\r\n                            },\r\n                            terminate: function () {\r\n                                if (d_1 && d_1.terminate)\r\n                                    d_1.terminate();\r\n                            }\r\n                        };\r\n                        if (sc_1 >= 0)\r\n                            file_1.size = sc_1, file_1.originalSize = su_1;\r\n                        this_1.onfile(file_1);\r\n                    }\r\n                    return \"break\";\r\n                }\r\n                else if (oc) {\r\n                    if (sig == 0x8074B50) {\r\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\r\n                        return \"break\";\r\n                    }\r\n                    else if (sig == 0x2014B50) {\r\n                        is = i -= 4, f = 3, this_1.c = 0;\r\n                        return \"break\";\r\n                    }\r\n                }\r\n            };\r\n            var this_1 = this;\r\n            for (; i < l - 4; ++i) {\r\n                var state_1 = _loop_2();\r\n                if (state_1 === \"break\")\r\n                    break;\r\n            }\r\n            this.p = et;\r\n            if (oc < 0) {\r\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\r\n                if (add)\r\n                    add.push(dat, !!f);\r\n                else\r\n                    this.k[+(f == 2)].push(dat);\r\n            }\r\n            if (f & 2)\r\n                return this.push(buf.subarray(i), final);\r\n            this.p = buf.subarray(i);\r\n        }\r\n        if (final) {\r\n            if (this.c)\r\n                err(13);\r\n            this.p = null;\r\n        }\r\n    };\r\n    /**\r\n     * Registers a decoder with the stream, allowing for files compressed with\r\n     * the compression type provided to be expanded correctly\r\n     * @param decoder The decoder constructor\r\n     */\r\n    Unzip.prototype.register = function (decoder) {\r\n        this.o[decoder.compression] = decoder;\r\n    };\r\n    return Unzip;\r\n}());\r\nexport { Unzip };\r\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\r\nexport function unzip(data, opts, cb) {\r\n    if (!cb)\r\n        cb = opts, opts = {};\r\n    if (typeof cb != 'function')\r\n        err(7);\r\n    var term = [];\r\n    var tAll = function () {\r\n        for (var i = 0; i < term.length; ++i)\r\n            term[i]();\r\n    };\r\n    var files = {};\r\n    var cbd = function (a, b) {\r\n        mt(function () { cb(a, b); });\r\n    };\r\n    mt(function () { cbd = cb; });\r\n    var e = data.length - 22;\r\n    for (; b4(data, e) != 0x6054B50; --e) {\r\n        if (!e || data.length - e > 65558) {\r\n            cbd(err(13, 0, 1), null);\r\n            return tAll;\r\n        }\r\n    }\r\n    ;\r\n    var lft = b2(data, e + 8);\r\n    if (lft) {\r\n        var c = lft;\r\n        var o = b4(data, e + 16);\r\n        var z = o == 4294967295 || c == 65535;\r\n        if (z) {\r\n            var ze = b4(data, e - 12);\r\n            z = b4(data, ze) == 0x6064B50;\r\n            if (z) {\r\n                c = lft = b4(data, ze + 32);\r\n                o = b4(data, ze + 48);\r\n            }\r\n        }\r\n        var fltr = opts && opts.filter;\r\n        var _loop_3 = function (i) {\r\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\r\n            o = no;\r\n            var cbl = function (e, d) {\r\n                if (e) {\r\n                    tAll();\r\n                    cbd(e, null);\r\n                }\r\n                else {\r\n                    if (d)\r\n                        files[fn] = d;\r\n                    if (!--lft)\r\n                        cbd(null, files);\r\n                }\r\n            };\r\n            if (!fltr || fltr({\r\n                name: fn,\r\n                size: sc,\r\n                originalSize: su,\r\n                compression: c_1\r\n            })) {\r\n                if (!c_1)\r\n                    cbl(null, slc(data, b, b + sc));\r\n                else if (c_1 == 8) {\r\n                    var infl = data.subarray(b, b + sc);\r\n                    // Synchronously decompress under 512KB, or barely-compressed data\r\n                    if (su < 524288 || sc > 0.8 * su) {\r\n                        try {\r\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\r\n                        }\r\n                        catch (e) {\r\n                            cbl(e, null);\r\n                        }\r\n                    }\r\n                    else\r\n                        term.push(inflate(infl, { size: su }, cbl));\r\n                }\r\n                else\r\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\r\n            }\r\n            else\r\n                cbl(null, null);\r\n        };\r\n        for (var i = 0; i < c; ++i) {\r\n            _loop_3(i);\r\n        }\r\n    }\r\n    else\r\n        cbd(null, {});\r\n    return tAll;\r\n}\r\n/**\r\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\r\n * performance with more than one file.\r\n * @param data The raw compressed ZIP file\r\n * @param opts The ZIP extraction options\r\n * @returns The decompressed files\r\n */\r\nexport function unzipSync(data, opts) {\r\n    var files = {};\r\n    var e = data.length - 22;\r\n    for (; b4(data, e) != 0x6054B50; --e) {\r\n        if (!e || data.length - e > 65558)\r\n            err(13);\r\n    }\r\n    ;\r\n    var c = b2(data, e + 8);\r\n    if (!c)\r\n        return {};\r\n    var o = b4(data, e + 16);\r\n    var z = o == 4294967295 || c == 65535;\r\n    if (z) {\r\n        var ze = b4(data, e - 12);\r\n        z = b4(data, ze) == 0x6064B50;\r\n        if (z) {\r\n            c = b4(data, ze + 32);\r\n            o = b4(data, ze + 48);\r\n        }\r\n    }\r\n    var fltr = opts && opts.filter;\r\n    for (var i = 0; i < c; ++i) {\r\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\r\n        o = no;\r\n        if (!fltr || fltr({\r\n            name: fn,\r\n            size: sc,\r\n            originalSize: su,\r\n            compression: c_2\r\n        })) {\r\n            if (!c_2)\r\n                files[fn] = slc(data, b, b + sc);\r\n            else if (c_2 == 8)\r\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\r\n            else\r\n                err(14, 'unknown compression type ' + c_2);\r\n        }\r\n    }\r\n    return files;\r\n}\r\n", "import { decompressSync } from \"fflate\";\nexport * from \"./adapters\";\n\n/** @hidden */\nexport interface BufferPosition {\n  buf: Uint8Array;\n  pos: number;\n}\n\nfunction toNum(low: number, high: number): number {\n  return (high >>> 0) * 0x100000000 + (low >>> 0);\n}\n\nfunction readVarintRemainder(l: number, p: BufferPosition): number {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let h = (b & 0x70) >> 4;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 3;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 10;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 17;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x7f) << 24;\n  if (b < 0x80) return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 0x01) << 31;\n  if (b < 0x80) return toNum(l, h);\n  throw new Error(\"Expected varint not more than 10 bytes\");\n}\n\n/** @hidden */\nexport function readVarint(p: BufferPosition): number {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let val = b & 0x7f;\n  if (b < 0x80) return val;\n  b = buf[p.pos++];\n  val |= (b & 0x7f) << 7;\n  if (b < 0x80) return val;\n  b = buf[p.pos++];\n  val |= (b & 0x7f) << 14;\n  if (b < 0x80) return val;\n  b = buf[p.pos++];\n  val |= (b & 0x7f) << 21;\n  if (b < 0x80) return val;\n  b = buf[p.pos];\n  val |= (b & 0x0f) << 28;\n\n  return readVarintRemainder(val, p);\n}\n\nfunction rotate(n: number, xy: number[], rx: number, ry: number): void {\n  if (ry === 0) {\n    if (rx === 1) {\n      xy[0] = n - 1 - xy[0];\n      xy[1] = n - 1 - xy[1];\n    }\n    const t = xy[0];\n    xy[0] = xy[1];\n    xy[1] = t;\n  }\n}\n\nfunction idOnLevel(z: number, pos: number): [number, number, number] {\n  const n = 2 ** z;\n  let rx = pos;\n  let ry = pos;\n  let t = pos;\n  const xy = [0, 0];\n  let s = 1;\n  while (s < n) {\n    rx = 1 & (t / 2);\n    ry = 1 & (t ^ rx);\n    rotate(s, xy, rx, ry);\n    xy[0] += s * rx;\n    xy[1] += s * ry;\n    t = t / 4;\n    s *= 2;\n  }\n  return [z, xy[0], xy[1]];\n}\n\nconst tzValues: number[] = [\n  0, 1, 5, 21, 85, 341, 1365, 5461, 21845, 87381, 349525, 1398101, 5592405,\n  22369621, 89478485, 357913941, 1431655765, 5726623061, 22906492245,\n  91625968981, 366503875925, 1466015503701, 5864062014805, 23456248059221,\n  93824992236885, 375299968947541, 1501199875790165,\n];\n\n/**\n * Convert Z,X,Y to a Hilbert TileID.\n */\nexport function zxyToTileId(z: number, x: number, y: number): number {\n  if (z > 26) {\n    throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");\n  }\n  if (x > 2 ** z - 1 || y > 2 ** z - 1) {\n    throw new Error(\"tile x/y outside zoom level bounds\");\n  }\n\n  const acc = tzValues[z];\n  const n = 2 ** z;\n  let rx = 0;\n  let ry = 0;\n  let d = 0;\n  const xy = [x, y];\n  let s = n / 2;\n  while (s > 0) {\n    rx = (xy[0] & s) > 0 ? 1 : 0;\n    ry = (xy[1] & s) > 0 ? 1 : 0;\n    d += s * s * ((3 * rx) ^ ry);\n    rotate(s, xy, rx, ry);\n    s = s / 2;\n  }\n  return acc + d;\n}\n\n/**\n * Convert a Hilbert TileID to Z,X,Y.\n */\nexport function tileIdToZxy(i: number): [number, number, number] {\n  let acc = 0;\n  const z = 0;\n\n  for (let z = 0; z < 27; z++) {\n    const numTiles = (0x1 << z) * (0x1 << z);\n    if (acc + numTiles > i) {\n      return idOnLevel(z, i - acc);\n    }\n    acc += numTiles;\n  }\n\n  throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");\n}\n\n/**\n * PMTiles v3 directory entry.\n */\nexport interface Entry {\n  tileId: number;\n  offset: number;\n  length: number;\n  runLength: number;\n}\n\ninterface MetadataLike {\n  attribution?: string;\n  name?: string;\n  version?: string;\n  // biome-ignore lint: TileJSON spec\n  vector_layers?: string;\n  description?: string;\n}\n\n/**\n * Enum representing a compression algorithm used.\n * 0 = unknown compression, for if you must use a different or unspecified algorithm.\n * 1 = no compression.\n */\nexport enum Compression {\n  Unknown = 0,\n  None = 1,\n  Gzip = 2,\n  Brotli = 3,\n  Zstd = 4,\n}\n\n/**\n * Provide a decompression implementation that acts on `buf` and returns decompressed data.\n *\n * Should use the native DecompressionStream on browsers, zlib on node.\n * Should throw if the compression algorithm is not supported.\n */\nexport type DecompressFunc = (\n  buf: ArrayBuffer,\n  compression: Compression\n) => Promise<ArrayBuffer>;\n\nasync function defaultDecompress(\n  buf: ArrayBuffer,\n  compression: Compression\n): Promise<ArrayBuffer> {\n  if (compression === Compression.None || compression === Compression.Unknown) {\n    return buf;\n  }\n  if (compression === Compression.Gzip) {\n    // biome-ignore lint: needed to detect DecompressionStream in browser+node+cloudflare workers\n    if (typeof (globalThis as any).DecompressionStream === \"undefined\") {\n      return decompressSync(new Uint8Array(buf));\n    }\n    const stream = new Response(buf).body;\n    if (!stream) {\n      throw new Error(\"Failed to read response stream\");\n    }\n    const result: ReadableStream<Uint8Array> = stream.pipeThrough(\n      // biome-ignore lint: needed to detect DecompressionStream in browser+node+cloudflare workers\n      new (globalThis as any).DecompressionStream(\"gzip\")\n    );\n    return new Response(result).arrayBuffer();\n  }\n  throw new Error(\"Compression method not supported\");\n}\n\n/**\n * Describe the type of tiles stored in the archive.\n * 0 is unknown/other, 1 is \"MVT\" vector tiles.\n */\nexport enum TileType {\n  Unknown = 0,\n  Mvt = 1,\n  Png = 2,\n  Jpeg = 3,\n  Webp = 4,\n  Avif = 5,\n}\n\nexport function tileTypeExt(t: TileType): string {\n  if (t === TileType.Mvt) return \".mvt\";\n  if (t === TileType.Png) return \".png\";\n  if (t === TileType.Jpeg) return \".jpg\";\n  if (t === TileType.Webp) return \".webp\";\n  if (t === TileType.Avif) return \".avif\";\n  return \"\";\n}\n\nconst HEADER_SIZE_BYTES = 127;\n\n/**\n * PMTiles v3 header storing basic archive-level information.\n */\nexport interface Header {\n  specVersion: number;\n  rootDirectoryOffset: number;\n  rootDirectoryLength: number;\n  jsonMetadataOffset: number;\n  jsonMetadataLength: number;\n  leafDirectoryOffset: number;\n  leafDirectoryLength?: number;\n  tileDataOffset: number;\n  tileDataLength?: number;\n  numAddressedTiles: number;\n  numTileEntries: number;\n  numTileContents: number;\n  clustered: boolean;\n  internalCompression: Compression;\n  tileCompression: Compression;\n  tileType: TileType;\n  minZoom: number;\n  maxZoom: number;\n  minLon: number;\n  minLat: number;\n  maxLon: number;\n  maxLat: number;\n  centerZoom: number;\n  centerLon: number;\n  centerLat: number;\n  etag?: string;\n}\n\n/**\n * Low-level function for looking up a TileID or leaf directory inside a directory.\n */\nexport function findTile(entries: Entry[], tileId: number): Entry | null {\n  let m = 0;\n  let n = entries.length - 1;\n  while (m <= n) {\n    const k = (n + m) >> 1;\n    const cmp = tileId - entries[k].tileId;\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return entries[k];\n    }\n  }\n\n  // at this point, m > n\n  if (n >= 0) {\n    if (entries[n].runLength === 0) {\n      return entries[n];\n    }\n    if (tileId - entries[n].tileId < entries[n].runLength) {\n      return entries[n];\n    }\n  }\n  return null;\n}\n\nexport interface RangeResponse {\n  data: ArrayBuffer;\n  etag?: string;\n  expires?: string;\n  cacheControl?: string;\n}\n\n/**\n * Interface for retrieving an archive from remote or local storage.\n */\nexport interface Source {\n  getBytes: (\n    offset: number,\n    length: number,\n    signal?: AbortSignal,\n    etag?: string\n  ) => Promise<RangeResponse>;\n\n  /**\n   * Return a unique string key for the archive e.g. a URL.\n   */\n  getKey: () => string;\n}\n\n/**\n * Use the Browser's File API, which is different from the NodeJS file API.\n * see https://developer.mozilla.org/en-US/docs/Web/API/File_API\n */\nexport class FileSource implements Source {\n  file: File;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  getKey() {\n    return this.file.name;\n  }\n\n  async getBytes(offset: number, length: number): Promise<RangeResponse> {\n    const blob = this.file.slice(offset, offset + length);\n    const a = await blob.arrayBuffer();\n    return { data: a };\n  }\n}\n\n/**\n * Uses the browser Fetch API to make tile requests via HTTP.\n *\n * This method does not send conditional request headers If-Match because of CORS.\n * Instead, it detects ETag mismatches via the response ETag or the 416 response code.\n *\n * This also works around browser and storage-specific edge cases.\n */\nexport class FetchSource implements Source {\n  url: string;\n\n  /**\n   * A [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) object, specfying custom [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) set for all requests to the remote archive.\n   *\n   * This should be used instead of maplibre's [transformRequest](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#example) for PMTiles archives.\n   */\n  customHeaders: Headers;\n  /** @hidden */\n  mustReload: boolean;\n  /** @hidden */\n  chromeWindowsNoCache: boolean;\n\n  constructor(url: string, customHeaders: Headers = new Headers()) {\n    this.url = url;\n    this.customHeaders = customHeaders;\n    this.mustReload = false;\n    let userAgent = \"\";\n    if (\"navigator\" in globalThis) {\n      //biome-ignore lint: cf workers\n      userAgent = (globalThis as any).navigator.userAgent || \"\";\n    }\n    const isWindows = userAgent.indexOf(\"Windows\") > -1;\n    const isChromiumBased = /Chrome|Chromium|Edg|OPR|Brave/.test(userAgent);\n    this.chromeWindowsNoCache = false;\n    if (isWindows && isChromiumBased) {\n      this.chromeWindowsNoCache = true;\n    }\n  }\n\n  getKey() {\n    return this.url;\n  }\n\n  /**\n   * Mutate the custom [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) set for all requests to the remote archive.\n   */\n  setHeaders(customHeaders: Headers) {\n    this.customHeaders = customHeaders;\n  }\n\n  async getBytes(\n    offset: number,\n    length: number,\n    passedSignal?: AbortSignal,\n    etag?: string\n  ): Promise<RangeResponse> {\n    let controller: AbortController | undefined;\n    let signal: AbortSignal | undefined;\n    if (passedSignal) {\n      signal = passedSignal;\n    } else {\n      controller = new AbortController();\n      signal = controller.signal;\n    }\n\n    const requestHeaders = new Headers(this.customHeaders);\n    requestHeaders.set(\"range\", `bytes=${offset}-${offset + length - 1}`);\n\n    // we don't send if match because:\n    // * it disables browser caching completely (Chromium)\n    // * it requires a preflight request for every tile request\n    // * it requires CORS configuration becasue If-Match is not a CORs-safelisted header\n    // CORs configuration should expose ETag.\n    // if any etag mismatch is detected, we need to ignore the browser cache\n    let cache: string | undefined;\n    if (this.mustReload) {\n      cache = \"reload\";\n    } else if (this.chromeWindowsNoCache) {\n      cache = \"no-store\";\n    }\n\n    let resp = await fetch(this.url, {\n      signal: signal,\n      cache: cache,\n      headers: requestHeaders,\n      //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n    } as any);\n\n    // handle edge case where the archive is < 16384 kb total.\n    if (offset === 0 && resp.status === 416) {\n      const contentRange = resp.headers.get(\"Content-Range\");\n      if (!contentRange || !contentRange.startsWith(\"bytes */\")) {\n        throw new Error(\"Missing content-length on 416 response\");\n      }\n      const actualLength = +contentRange.substr(8);\n      resp = await fetch(this.url, {\n        signal: signal,\n        cache: \"reload\",\n        headers: { range: `bytes=0-${actualLength - 1}` },\n        //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n      } as any);\n    }\n\n    // if it's a weak etag, it's not useful for us, so ignore it.\n    let newEtag = resp.headers.get(\"Etag\");\n    if (newEtag?.startsWith(\"W/\")) {\n      newEtag = null;\n    }\n\n    // some storage systems are misbehaved (Cloudflare R2)\n    if (resp.status === 416 || (etag && newEtag && newEtag !== etag)) {\n      this.mustReload = true;\n      throw new EtagMismatch(\n        `Server returned non-matching ETag ${etag} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`\n      );\n    }\n\n    if (resp.status >= 300) {\n      throw new Error(`Bad response code: ${resp.status}`);\n    }\n\n    // some well-behaved backends, e.g. DigitalOcean CDN, respond with 200 instead of 206\n    // but we also need to detect no support for Byte Serving which is returning the whole file\n    const contentLength = resp.headers.get(\"Content-Length\");\n    if (resp.status === 200 && (!contentLength || +contentLength > length)) {\n      if (controller) controller.abort();\n      throw new Error(\n        \"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\"\n      );\n    }\n\n    const a = await resp.arrayBuffer();\n    return {\n      data: a,\n      etag: newEtag || undefined,\n      cacheControl: resp.headers.get(\"Cache-Control\") || undefined,\n      expires: resp.headers.get(\"Expires\") || undefined,\n    };\n  }\n}\n\n/** @hidden */\nexport function getUint64(v: DataView, offset: number): number {\n  const wh = v.getUint32(offset + 4, true);\n  const wl = v.getUint32(offset + 0, true);\n  return wh * 2 ** 32 + wl;\n}\n\n/**\n * Parse raw header bytes into a Header object.\n */\nexport function bytesToHeader(bytes: ArrayBuffer, etag?: string): Header {\n  const v = new DataView(bytes);\n  const specVersion = v.getUint8(7);\n  if (specVersion > 3) {\n    throw new Error(\n      `Archive is spec version ${specVersion} but this library supports up to spec version 3`\n    );\n  }\n\n  return {\n    specVersion: specVersion,\n    rootDirectoryOffset: getUint64(v, 8),\n    rootDirectoryLength: getUint64(v, 16),\n    jsonMetadataOffset: getUint64(v, 24),\n    jsonMetadataLength: getUint64(v, 32),\n    leafDirectoryOffset: getUint64(v, 40),\n    leafDirectoryLength: getUint64(v, 48),\n    tileDataOffset: getUint64(v, 56),\n    tileDataLength: getUint64(v, 64),\n    numAddressedTiles: getUint64(v, 72),\n    numTileEntries: getUint64(v, 80),\n    numTileContents: getUint64(v, 88),\n    clustered: v.getUint8(96) === 1,\n    internalCompression: v.getUint8(97),\n    tileCompression: v.getUint8(98),\n    tileType: v.getUint8(99),\n    minZoom: v.getUint8(100),\n    maxZoom: v.getUint8(101),\n    minLon: v.getInt32(102, true) / 10000000,\n    minLat: v.getInt32(106, true) / 10000000,\n    maxLon: v.getInt32(110, true) / 10000000,\n    maxLat: v.getInt32(114, true) / 10000000,\n    centerZoom: v.getUint8(118),\n    centerLon: v.getInt32(119, true) / 10000000,\n    centerLat: v.getInt32(123, true) / 10000000,\n    etag: etag,\n  };\n}\n\nfunction deserializeIndex(buffer: ArrayBuffer): Entry[] {\n  const p = { buf: new Uint8Array(buffer), pos: 0 };\n  const numEntries = readVarint(p);\n\n  const entries: Entry[] = [];\n\n  let lastId = 0;\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    entries.push({ tileId: lastId + v, offset: 0, length: 0, runLength: 1 });\n    lastId += v;\n  }\n\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].runLength = readVarint(p);\n  }\n\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].length = readVarint(p);\n  }\n\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    if (v === 0 && i > 0) {\n      entries[i].offset = entries[i - 1].offset + entries[i - 1].length;\n    } else {\n      entries[i].offset = v - 1;\n    }\n  }\n\n  return entries;\n}\n\nfunction detectVersion(a: ArrayBuffer): number {\n  const v = new DataView(a);\n  if (v.getUint16(2, true) === 2) {\n    console.error(\n      \"PMTiles spec version 2 is not supported; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 2;\n  }\n  if (v.getUint16(2, true) === 1) {\n    console.error(\n      \"PMTiles spec version 1 is not supported; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 1;\n  }\n  return 3;\n}\n\n/**\n * Error thrown when a response for PMTiles over HTTP does not match previous, cached parts of the archive.\n * The default PMTiles implementation will catch this error once internally and retry a request.\n */\nexport class EtagMismatch extends Error {}\n\n/**\n * Interface for caches of parts (headers, directories) of a PMTiles archive.\n */\nexport interface Cache {\n  getHeader: (source: Source) => Promise<Header>;\n  getDirectory: (\n    source: Source,\n    offset: number,\n    length: number,\n    header: Header\n  ) => Promise<Entry[]>;\n  invalidate: (source: Source) => Promise<void>;\n}\n\nasync function getHeaderAndRoot(\n  source: Source,\n  decompress: DecompressFunc\n): Promise<[Header, [string, number, Entry[] | ArrayBuffer]?]> {\n  const resp = await source.getBytes(0, 16384);\n\n  const v = new DataView(resp.data);\n  if (v.getUint16(0, true) !== 0x4d50) {\n    throw new Error(\"Wrong magic number for PMTiles archive\");\n  }\n\n  const headerData = resp.data.slice(0, HEADER_SIZE_BYTES);\n\n  const header = bytesToHeader(headerData, resp.etag);\n\n  // optimistically set the root directory\n  // TODO check root bounds\n  const rootDirData = resp.data.slice(\n    header.rootDirectoryOffset,\n    header.rootDirectoryOffset + header.rootDirectoryLength\n  );\n  const dirKey = `${source.getKey()}|${header.etag || \"\"}|${\n    header.rootDirectoryOffset\n  }|${header.rootDirectoryLength}`;\n\n  const rootDir = deserializeIndex(\n    await decompress(rootDirData, header.internalCompression)\n  );\n  return [header, [dirKey, rootDir.length, rootDir]];\n}\n\nasync function getDirectory(\n  source: Source,\n  decompress: DecompressFunc,\n  offset: number,\n  length: number,\n  header: Header\n): Promise<Entry[]> {\n  const resp = await source.getBytes(offset, length, undefined, header.etag);\n  const data = await decompress(resp.data, header.internalCompression);\n  const directory = deserializeIndex(data);\n  if (directory.length === 0) {\n    throw new Error(\"Empty directory is invalid\");\n  }\n\n  return directory;\n}\n\ninterface ResolvedValue {\n  lastUsed: number;\n  data: Header | Entry[] | ArrayBuffer;\n}\n\n/**\n * A cache for parts of a PMTiles archive where promises are never shared between requests.\n *\n * Runtimes such as Cloudflare Workers cannot share promises between different requests.\n *\n * Only caches headers and directories, not individual tile contents.\n */\nexport class ResolvedValueCache {\n  cache: Map<string, ResolvedValue>;\n  maxCacheEntries: number;\n  counter: number;\n  decompress: DecompressFunc;\n\n  constructor(\n    maxCacheEntries = 100,\n    prefetch = true, // deprecated\n    decompress: DecompressFunc = defaultDecompress\n  ) {\n    this.cache = new Map<string, ResolvedValue>();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n\n  async getHeader(source: Source): Promise<Header> {\n    const cacheKey = source.getKey();\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = cacheValue.data;\n      return data as Header;\n    }\n\n    const res = await getHeaderAndRoot(source, this.decompress);\n    if (res[1]) {\n      this.cache.set(res[1][0], {\n        lastUsed: this.counter++,\n        data: res[1][2],\n      });\n    }\n\n    this.cache.set(cacheKey, {\n      lastUsed: this.counter++,\n      data: res[0],\n    });\n    this.prune();\n    return res[0];\n  }\n\n  async getDirectory(\n    source: Source,\n    offset: number,\n    length: number,\n    header: Header\n  ): Promise<Entry[]> {\n    const cacheKey = `${source.getKey()}|${\n      header.etag || \"\"\n    }|${offset}|${length}`;\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = cacheValue.data;\n      return data as Entry[];\n    }\n\n    const directory = await getDirectory(\n      source,\n      this.decompress,\n      offset,\n      length,\n      header\n    );\n    this.cache.set(cacheKey, {\n      lastUsed: this.counter++,\n      data: directory,\n    });\n    this.prune();\n    return directory;\n  }\n\n  prune() {\n    if (this.cache.size > this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = undefined;\n      this.cache.forEach((cacheValue: ResolvedValue, key: string) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n\n  async invalidate(source: Source) {\n    this.cache.delete(source.getKey());\n  }\n}\n\ninterface SharedPromiseCacheValue {\n  lastUsed: number;\n  data: Promise<Header | Entry[] | ArrayBuffer>;\n}\n\n/**\n * A cache for parts of a PMTiles archive where promises can be shared between requests.\n *\n * Only caches headers and directories, not individual tile contents.\n */\nexport class SharedPromiseCache {\n  cache: Map<string, SharedPromiseCacheValue>;\n  invalidations: Map<string, Promise<void>>;\n  maxCacheEntries: number;\n  counter: number;\n  decompress: DecompressFunc;\n\n  constructor(\n    maxCacheEntries = 100,\n    prefetch = true, // deprecated\n    decompress: DecompressFunc = defaultDecompress\n  ) {\n    this.cache = new Map<string, SharedPromiseCacheValue>();\n    this.invalidations = new Map<string, Promise<void>>();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n\n  async getHeader(source: Source): Promise<Header> {\n    const cacheKey = source.getKey();\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = await cacheValue.data;\n      return data as Header;\n    }\n\n    const p = new Promise<Header>((resolve, reject) => {\n      getHeaderAndRoot(source, this.decompress)\n        .then((res) => {\n          if (res[1]) {\n            this.cache.set(res[1][0], {\n              lastUsed: this.counter++,\n              data: Promise.resolve(res[1][2]),\n            });\n          }\n          resolve(res[0]);\n          this.prune();\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n    return p;\n  }\n\n  async getDirectory(\n    source: Source,\n    offset: number,\n    length: number,\n    header: Header\n  ): Promise<Entry[]> {\n    const cacheKey = `${source.getKey()}|${\n      header.etag || \"\"\n    }|${offset}|${length}`;\n    const cacheValue = this.cache.get(cacheKey);\n    if (cacheValue) {\n      cacheValue.lastUsed = this.counter++;\n      const data = await cacheValue.data;\n      return data as Entry[];\n    }\n\n    const p = new Promise<Entry[]>((resolve, reject) => {\n      getDirectory(source, this.decompress, offset, length, header)\n        .then((directory) => {\n          resolve(directory);\n          this.prune();\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n    return p;\n  }\n\n  prune() {\n    if (this.cache.size >= this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = undefined;\n      this.cache.forEach((cacheValue: SharedPromiseCacheValue, key: string) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n\n  async invalidate(source: Source) {\n    const key = source.getKey();\n    if (this.invalidations.get(key)) {\n      return await this.invalidations.get(key);\n    }\n    this.cache.delete(source.getKey());\n    const p = new Promise<void>((resolve, reject) => {\n      this.getHeader(source)\n        .then((h) => {\n          resolve();\n          this.invalidations.delete(key);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    this.invalidations.set(key, p);\n  }\n}\n\n/**\n * Main class encapsulating PMTiles decoding logic.\n *\n * if `source` is a string, creates a FetchSource using that string as the URL to a remote PMTiles.\n * if no `cache` is passed, use a SharedPromiseCache.\n * if no `decompress` is passed, default to the browser DecompressionStream API with a fallback to `fflate`.\n */\n// biome-ignore lint: that's just how its capitalized\nexport class PMTiles {\n  source: Source;\n  cache: Cache;\n  decompress: DecompressFunc;\n\n  constructor(\n    source: Source | string,\n    cache?: Cache,\n    decompress?: DecompressFunc\n  ) {\n    if (typeof source === \"string\") {\n      this.source = new FetchSource(source);\n    } else {\n      this.source = source;\n    }\n    if (decompress) {\n      this.decompress = decompress;\n    } else {\n      this.decompress = defaultDecompress;\n    }\n    if (cache) {\n      this.cache = cache;\n    } else {\n      this.cache = new SharedPromiseCache();\n    }\n  }\n\n  /**\n   * Return the header of the archive,\n   * including information such as tile type, min/max zoom, bounds, and summary statistics.\n   */\n  async getHeader() {\n    return await this.cache.getHeader(this.source);\n  }\n\n  /** @hidden */\n  async getZxyAttempt(\n    z: number,\n    x: number,\n    y: number,\n    signal?: AbortSignal\n  ): Promise<RangeResponse | undefined> {\n    const tileId = zxyToTileId(z, x, y);\n    const header = await this.cache.getHeader(this.source);\n\n    if (z < header.minZoom || z > header.maxZoom) {\n      return undefined;\n    }\n\n    let dO = header.rootDirectoryOffset;\n    let dL = header.rootDirectoryLength;\n    for (let depth = 0; depth <= 3; depth++) {\n      const directory = await this.cache.getDirectory(\n        this.source,\n        dO,\n        dL,\n        header\n      );\n      const entry = findTile(directory, tileId);\n      if (entry) {\n        if (entry.runLength > 0) {\n          const resp = await this.source.getBytes(\n            header.tileDataOffset + entry.offset,\n            entry.length,\n            signal,\n            header.etag\n          );\n          return {\n            data: await this.decompress(resp.data, header.tileCompression),\n            cacheControl: resp.cacheControl,\n            expires: resp.expires,\n          };\n        }\n        dO = header.leafDirectoryOffset + entry.offset;\n        dL = entry.length;\n      } else {\n        // TODO: We should in fact return a valid RangeResponse\n        // with empty data, but filled in cache control / expires headers\n        return undefined;\n      }\n    }\n    throw new Error(\"Maximum directory depth exceeded\");\n  }\n\n  /**\n   * Primary method to get a single tile's bytes from an archive.\n   *\n   * Returns undefined if the tile does not exist in the archive.\n   */\n  async getZxy(\n    z: number,\n    x: number,\n    y: number,\n    signal?: AbortSignal\n  ): Promise<RangeResponse | undefined> {\n    try {\n      return await this.getZxyAttempt(z, x, y, signal);\n    } catch (e) {\n      if (e instanceof EtagMismatch) {\n        this.cache.invalidate(this.source);\n        return await this.getZxyAttempt(z, x, y, signal);\n      }\n      throw e;\n    }\n  }\n\n  /** @hidden */\n  async getMetadataAttempt(): Promise<unknown> {\n    const header = await this.cache.getHeader(this.source);\n\n    const resp = await this.source.getBytes(\n      header.jsonMetadataOffset,\n      header.jsonMetadataLength,\n      undefined,\n      header.etag\n    );\n    const decompressed = await this.decompress(\n      resp.data,\n      header.internalCompression\n    );\n    const dec = new TextDecoder(\"utf-8\");\n    return JSON.parse(dec.decode(decompressed));\n  }\n\n  /**\n   * Return the arbitrary JSON metadata of the archive.\n   */\n  async getMetadata(): Promise<unknown> {\n    try {\n      return await this.getMetadataAttempt();\n    } catch (e) {\n      if (e instanceof EtagMismatch) {\n        this.cache.invalidate(this.source);\n        return await this.getMetadataAttempt();\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Construct a [TileJSON](https://github.com/mapbox/tilejson-spec) object.\n   *\n   * baseTilesUrl is the desired tiles URL, excluding the suffix `/{z}/{x}/{y}.{ext}`.\n   * For example, if the desired URL is `http://example.com/tileset/{z}/{x}/{y}.mvt`,\n   * the baseTilesUrl should be `https://example.com/tileset`.\n   */\n  async getTileJson(baseTilesUrl: string): Promise<unknown> {\n    const header = await this.getHeader();\n    const metadata = (await this.getMetadata()) as MetadataLike;\n    const ext = tileTypeExt(header.tileType);\n\n    return {\n      tilejson: \"3.0.0\",\n      scheme: \"xyz\",\n      tiles: [`${baseTilesUrl}/{z}/{x}/{y}${ext}`],\n      // biome-ignore lint: TileJSON spec\n      vector_layers: metadata.vector_layers,\n      attribution: metadata.attribution,\n      description: metadata.description,\n      name: metadata.name,\n      version: metadata.version,\n      bounds: [header.minLon, header.minLat, header.maxLon, header.maxLat],\n      center: [header.centerLon, header.centerLat, header.centerZoom],\n      minzoom: header.minZoom,\n      maxzoom: header.maxZoom,\n    };\n  }\n}\n", "// biome-ignore lint: needed for Leaflet + IIFE to work\ndeclare const L: any;\n// biome-ignore lint: needed for window.URL to disambiguate from cloudflare workers\ndeclare const window: any;\ndeclare const document: DocumentLike;\n\nimport type { Coords } from \"leaflet\";\nimport { PMTiles, TileType } from \"./index\";\n\ninterface DocumentLike {\n  // biome-ignore lint: we don't want to bring in the entire document type\n  createElement: (s: string) => any;\n}\n\n// biome-ignore lint: we don't want to bring in the entire document type\ntype DoneCallback = (error?: Error, tile?: any) => void;\n\n/**\n * Add a raster PMTiles as a layer to a Leaflet map.\n *\n * For vector tiles see https://github.com/protomaps/protomaps-leaflet\n */\nexport const leafletRasterLayer = (source: PMTiles, options: unknown) => {\n  let loaded = false;\n  let mimeType = \"\";\n  const cls = L.GridLayer.extend({\n    createTile: (coord: Coords, done: DoneCallback) => {\n      const el = document.createElement(\"img\");\n      const controller = new AbortController();\n      const signal = controller.signal;\n      el.cancel = () => {\n        controller.abort();\n      };\n      if (!loaded) {\n        source.getHeader().then((header) => {\n          if (header.tileType === TileType.Mvt) {\n            console.error(\n              \"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\"\n            );\n          } else if (header.tileType === 2) {\n            mimeType = \"image/png\";\n          } else if (header.tileType === 3) {\n            mimeType = \"image/jpeg\";\n          } else if (header.tileType === 4) {\n            mimeType = \"image/webp\";\n          } else if (header.tileType === 5) {\n            mimeType = \"image/avif\";\n          }\n        });\n        loaded = true;\n      }\n      source\n        .getZxy(coord.z, coord.x, coord.y, signal)\n        .then((arr) => {\n          if (arr) {\n            const blob = new Blob([arr.data], { type: mimeType });\n            const imageUrl = window.URL.createObjectURL(blob);\n            el.src = imageUrl;\n            el.cancel = undefined;\n            done(undefined, el);\n          }\n        })\n        .catch((e) => {\n          if (e.name !== \"AbortError\") {\n            throw e;\n          }\n        });\n      return el;\n    },\n\n    _removeTile: function (key: string) {\n      const tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n\n      if (tile.el.cancel) tile.el.cancel();\n\n      tile.el.width = 0;\n      tile.el.height = 0;\n      tile.el.deleted = true;\n      L.DomUtil.remove(tile.el);\n      delete this._tiles[key];\n      this.fire(\"tileunload\", {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key),\n      });\n    },\n  });\n  return new cls(options);\n};\n\ntype GetResourceResponse<T> = ExpiryData & {\n  data: T;\n};\ntype AddProtocolAction = (\n  requestParameters: RequestParameters,\n  abortController: AbortController\n) => Promise<GetResourceResponse<unknown>>;\n\ntype ExpiryData = {\n  cacheControl?: string | null;\n  expires?: string | null; // MapLibre can be a Date object\n};\n\n// copied from MapLibre /util/ajax.ts\ntype RequestParameters = {\n  url: string;\n  headers?: unknown;\n  method?: \"GET\" | \"POST\" | \"PUT\";\n  body?: string;\n  type?: \"string\" | \"json\" | \"arrayBuffer\" | \"image\";\n  credentials?: \"same-origin\" | \"include\";\n  collectResourceTiming?: boolean;\n};\n\n// for legacy maplibre-3 interop\ntype ResponseCallbackV3 = (\n  error?: Error | undefined,\n  data?: unknown | undefined,\n  cacheControl?: string | undefined,\n  expires?: string | undefined\n) => void;\n\ntype V3OrV4Protocol = <\n  T extends AbortController | ResponseCallbackV3,\n  R = T extends AbortController\n    ? Promise<GetResourceResponse<unknown>>\n    : { cancel: () => void },\n>(\n  requestParameters: RequestParameters,\n  arg2: T\n) => R;\n\nconst v3compat =\n  (v4: AddProtocolAction): V3OrV4Protocol =>\n  (requestParameters, arg2) => {\n    if (arg2 instanceof AbortController) {\n      // biome-ignore lint: overloading return type not handled by compiler\n      return v4(requestParameters, arg2) as any;\n    }\n    const abortController = new AbortController();\n    v4(requestParameters, abortController)\n      .then(\n        (result) => {\n          return arg2(\n            undefined,\n            result.data,\n            result.cacheControl || \"\",\n            result.expires || \"\"\n          );\n        },\n        (err) => {\n          return arg2(err);\n        }\n      )\n      .catch((e) => {\n        return arg2(e);\n      });\n    return { cancel: () => abortController.abort() };\n  };\n\n/**\n * MapLibre GL JS protocol. Must be added once globally.\n */\nexport class Protocol {\n  /** @hidden */\n  tiles: Map<string, PMTiles>;\n  metadata: boolean;\n  errorOnMissingTile: boolean;\n\n  /**\n   * Initialize the MapLibre PMTiles protocol.\n   *\n   * * metadata: also load the metadata section of the PMTiles. required for some \"inspect\" functionality\n   * and to automatically populate the map attribution. Requires an extra HTTP request.\n   * * errorOnMissingTile: When a vector MVT tile is missing from the archive, raise an error instead of\n   * returning the empty array. Not recommended. This is only to reproduce the behavior of ZXY tile APIs\n   * which some applications depend on when overzooming.\n   */\n  constructor(options?: { metadata?: boolean; errorOnMissingTile?: boolean }) {\n    this.tiles = new Map<string, PMTiles>();\n    this.metadata = options?.metadata || false;\n    this.errorOnMissingTile = options?.errorOnMissingTile || false;\n  }\n\n  /**\n   * Add a {@link PMTiles} instance to the global protocol instance.\n   *\n   * For remote fetch sources, references in MapLibre styles like pmtiles://http://...\n   * will resolve to the same instance if the URLs match.\n   */\n  add(p: PMTiles) {\n    this.tiles.set(p.source.getKey(), p);\n  }\n\n  /**\n   * Fetch a {@link PMTiles} instance by URL, for remote PMTiles instances.\n   */\n  get(url: string) {\n    return this.tiles.get(url);\n  }\n\n  /** @hidden */\n  tilev4 = async (\n    params: RequestParameters,\n    abortController: AbortController\n  ) => {\n    if (params.type === \"json\") {\n      const pmtilesUrl = params.url.substr(10);\n      let instance = this.tiles.get(pmtilesUrl);\n      if (!instance) {\n        instance = new PMTiles(pmtilesUrl);\n        this.tiles.set(pmtilesUrl, instance);\n      }\n\n      if (this.metadata) {\n        return {\n          data: await instance.getTileJson(params.url),\n        };\n      }\n\n      const h = await instance.getHeader();\n\n      if (h.minLon >= h.maxLon || h.minLat >= h.maxLat) {\n        console.error(\n          `Bounds of PMTiles archive ${h.minLon},${h.minLat},${h.maxLon},${h.maxLat} are not valid.`\n        );\n      }\n\n      return {\n        data: {\n          tiles: [`${params.url}/{z}/{x}/{y}`],\n          minzoom: h.minZoom,\n          maxzoom: h.maxZoom,\n          bounds: [h.minLon, h.minLat, h.maxLon, h.maxLat],\n        },\n      };\n    }\n    const re = new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/);\n    const result = params.url.match(re);\n    if (!result) {\n      throw new Error(\"Invalid PMTiles protocol URL\");\n    }\n    const pmtilesUrl = result[1];\n\n    let instance = this.tiles.get(pmtilesUrl);\n    if (!instance) {\n      instance = new PMTiles(pmtilesUrl);\n      this.tiles.set(pmtilesUrl, instance);\n    }\n    const z = result[2];\n    const x = result[3];\n    const y = result[4];\n\n    const header = await instance.getHeader();\n    const resp = await instance?.getZxy(+z, +x, +y, abortController.signal);\n    if (resp) {\n      return {\n        data: new Uint8Array(resp.data),\n        cacheControl: resp.cacheControl,\n        expires: resp.expires,\n      };\n    }\n    if (header.tileType === TileType.Mvt) {\n      if (this.errorOnMissingTile) {\n        throw new Error(\"Tile not found.\");\n      }\n      return { data: new Uint8Array() };\n    }\n    return { data: null };\n  };\n\n  tile = v3compat(this.tilev4);\n}\n"],
  "mappings": "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",
  "names": ["w", "err", "b", "j", "x", "l", "v", "m", "l", "b", "v", "w", "_a", "_b", "i", "j", "k", "m", "b", "k", "td", "v", "m", "w", "err", "b", "v", "l", "fl", "Deflate", "AsyncDeflate", "Inflate", "AsyncInflate", "Gzip", "Gunzip", "AsyncGunzip", "Zlib", "Unzlib", "AsyncUnzlib", "Decompress", "AsyncDecompress", "err", "DecodeUTF8", "_a", "EncodeUTF8", "l", "w", "v", "_a", "l", "b", "k", "l", "fl", "ZipPassThrough", "ZipDeflate", "AsyncZipDeflate", "err", "Zip", "err", "l", "_a", "_b", "UnzipPassThrough", "UnzipInflate", "AsyncUnzipInflate", "_", "err", "Unzip", "l", "_a", "err", "dat", "final", "leafletRasterLayer", "__name", "source", "options", "loaded", "mimeType", "cls", "coord", "done", "el", "controller", "signal", "header", "arr", "blob", "imageUrl", "e", "key", "tile", "v3compat", "v4", "requestParameters", "arg2", "abortController", "result", "err", "_Protocol", "params", "__async", "pmtilesUrl", "instance", "PMTiles", "h", "re", "z", "x", "y", "resp", "p", "url", "Protocol", "toNum", "low", "high", "readVarintRemainder", "l", "buf", "b", "readVarint", "val", "rotate", "n", "xy", "rx", "ry", "t", "idOnLevel", "pos", "__pow", "s", "tzValues", "zxyToTileId", "acc", "d", "tileIdToZxy", "numTiles", "Compression", "defaultDecompress", "compression", "decompressSync", "stream", "TileType", "tileTypeExt", "HEADER_SIZE_BYTES", "findTile", "entries", "tileId", "m", "k", "cmp", "_FileSource", "file", "offset", "length", "FileSource", "_FetchSource", "customHeaders", "userAgent", "isWindows", "isChromiumBased", "passedSignal", "etag", "requestHeaders", "cache", "contentRange", "actualLength", "newEtag", "EtagMismatch", "contentLength", "FetchSource", "getUint64", "v", "wh", "wl", "bytesToHeader", "bytes", "specVersion", "deserializeIndex", "buffer", "numEntries", "lastId", "i", "_EtagMismatch", "getHeaderAndRoot", "decompress", "headerData", "rootDirData", "dirKey", "rootDir", "getDirectory", "data", "directory", "_ResolvedValueCache", "maxCacheEntries", "prefetch", "cacheKey", "cacheValue", "res", "minUsed", "minKey", "ResolvedValueCache", "_SharedPromiseCache", "resolve", "reject", "SharedPromiseCache", "_PMTiles", "dO", "dL", "depth", "entry", "decompressed", "dec", "baseTilesUrl", "metadata", "ext"]
}
